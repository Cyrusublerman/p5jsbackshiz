// Extracted metadata module (safe text representation)
export const TOOL_SOURCE_PATH = "toIntegrate/tile2/tile2/src/script.js";
export const TOOL_EXTRACTION_MODE = "regex-only";
export const TOOL_FUNCTION_NAMES = [
  "buildWorkerSource",
  "compile",
  "createProgram",
  "getUniformLocations",
  "initGL",
  "init2D",
  "setViewport",
  "createTextureFromSource",
  "resampleBitmap",
  "render",
  "createWorker",
  "initAnimationEngine",
  "_toBitmap",
  "loadImagesFromUrls",
  "_tick",
  "play",
  "pause",
  "setFps",
  "setParams",
  "setZoom",
  "main",
  "pushParams",
  "pushZoom"
];
export const TOOL_REGEX_FUNCTION_NAMES = [
  "buildWorkerSource",
  "compile",
  "createProgram",
  "getUniformLocations",
  "initGL",
  "init2D",
  "setViewport",
  "createTextureFromSource",
  "resampleBitmap",
  "render",
  "createWorker",
  "initAnimationEngine",
  "_toBitmap",
  "loadImagesFromUrls",
  "_tick",
  "play",
  "pause",
  "setFps",
  "setParams",
  "setZoom",
  "main",
  "pushParams",
  "pushZoom"
];
export const TOOL_LLM_FUNCTION_NAMES = [];
export const TOOL_LLM_CAPABILITIES = [];
export const TOOL_LLM_NOTES = "";
export const TOOL_SOURCE_TEXT = "// ---------- Drop-in single-pen engine (Worker built from Blob URL) ----------\n\n// Globals (kept for compatibility with your codebase)\n\nconst images = new Map();\n\nlet processedImages = Object.create(null);\n\nlet processedImageDatas = Object.create(null);\n\nlet allCombinations = [];\n\nlet currentFrame = 0;\n\nlet animationInterval = null;        // not used (we use rAF)\n\nlet playing = false;\n\nlet animationSpeed = 1000 / 24;\n\nlet isGeneratingGIF = false;         // disabled on CodePen\n\nlet gifPreviewBlobUrl = null;\n\nlet equationEngine = null;\n\nlet equationValidator = null;\n\nlet currentEquation = null;\n\nlet mainCanvas = null;\n\nlet mainCtx = null;                  // unused; we render in worker\n\nlet offscreenCanvas = null;\n\nlet offscreenCtx = null;\n\nconst IMAGE_SETTINGS = {\n\n  maxShortSide: 768,\n\n  autoResize: true\n\n};\n\nlet zoomState = {\n\n  scale: 1,\n\n  panX: 0,\n\n  panY: 0,\n\n  isPanning: false,\n\n  startX: 0,\n\n  startY: 0\n\n};\n\nconst performanceMetrics = {\n\n  lastFrameTime: 0,\n\n  frameCount: 0,\n\n  fps: 0\n\n};\n\n// Internal state\n\nlet _worker = null;\n\nlet _offscreen = null;\n\nlet _bitmaps = [];\n\nlet _lastT = 0;\n\nlet _targetFps = 24;\n\nlet _rAF = 0;\n\nlet _ready = false;\n\nlet _canvasPixelWidth = 1;\n\nlet _canvasPixelHeight = 1;\n\n// Build worker source as a string (no imports; compatible with Blob URL)\n\nfunction buildWorkerSource() {\n\n  // GLSL strings\n\n  const VERT = `#version 300 es\n\n  precision highp float;\n\n  layout(location=0) in vec2 a_pos;\n\n  layout(location=1) in vec2 a_uv;\n\n  out vec2 v_uv;\n\n  uniform vec2 u_canvasSize;\n\n  uniform vec3 u_zoom; // scale, panX, panY (px)\n\n  void main(){\n\n    vec2 halfSize = u_canvasSize * 0.5;\n\n    vec2 px = a_pos * halfSize;\n\n    px = (px * u_zoom.x) + u_zoom.yz;\n\n    vec2 ndc = px / halfSize;\n\n    gl_Position = vec4(ndc, 0.0, 1.0);\n\n    v_uv = a_uv;\n\n  }`;\n\n  const FRAG = `#version 300 es\n\n  precision highp float;\n\n  in vec2 v_uv;\n\n  out vec4 fragColor;\n\n  uniform sampler2D u_tex0;\n\n  uniform sampler2D u_tex1;\n\n  uniform float u_mix;\n\n  uniform int   u_mode;\n\n  uniform float u_exposure;\n\n  uniform float u_invGamma;\n\n  vec3 toneMap(vec3 c, float exposure, float invGamma){\n\n    float k = exp2(exposure);\n\n    vec3 v = max(vec3(0.0), c * k);\n\n    return pow(v, vec3(invGamma));\n\n  }\n\n  void main(){\n\n    vec4 a = texture(u_tex0, v_uv);\n\n    vec4 b = texture(u_tex1, v_uv);\n\n    vec3 outRGB;\n\n    if (u_mode == 0) {\n\n      outRGB = a.rgb;\n\n    } else if (u_mode == 1) {\n\n      outRGB = mix(a.rgb, b.rgb, clamp(u_mix, 0.0, 1.0));\n\n    } else if (u_mode == 2) {\n\n      outRGB = a.rgb * b.rgb;\n\n    } else {\n\n      outRGB = abs(a.rgb - b.rgb);\n\n    }\n\n    outRGB = toneMap(outRGB, u_exposure, u_invGamma);\n\n    fragColor = vec4(outRGB, 1.0);\n\n  }`;\n\n  return `\n\n  let canvas = null;\n\n  let width = 1, height = 1, fps = 24;\n\n  let gl = null, ctx2d = null;\n\n  let program = null, vao = null, uniforms = {};\n\n  let textures = [];\n\n  let imagesMeta = [];\n\n  let effect = 'passthrough';\n\n  let exposure = 0.0;\n\n  let gamma = 1.0;\n\n  let zoom = { scale: 1, panX: 0, panY: 0 };\n\n  let frameCounter = 0;\n\n  const VERT = \\`${VERT}\\`;\n\n  const FRAG = \\`${FRAG}\\`;\n\n  function compile(gl, type, src){\n\n    const sh = gl.createShader(type);\n\n    gl.shaderSource(sh, src);\n\n    gl.compileShader(sh);\n\n    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){\n\n      const log = gl.getShaderInfoLog(sh);\n\n      gl.deleteShader(sh);\n\n      throw new Error('Shader compile error: ' + log);\n\n    }\n\n    return sh;\n\n  }\n\n  function createProgram(gl, vsSrc, fsSrc){\n\n    const vs = compile(gl, gl.VERTEX_SHADER, vsSrc);\n\n    const fs = compile(gl, gl.FRAGMENT_SHADER, fsSrc);\n\n    const prog = gl.createProgram();\n\n    gl.attachShader(prog, vs);\n\n    gl.attachShader(prog, fs);\n\n    gl.linkProgram(prog);\n\n    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){\n\n      const log = gl.getProgramInfoLog(prog);\n\n      gl.deleteProgram(prog);\n\n      throw new Error('Program link error: ' + log);\n\n    }\n\n    gl.deleteShader(vs);\n\n    gl.deleteShader(fs);\n\n    return prog;\n\n  }\n\n  function getUniformLocations(gl, prog, names){\n\n    const out = {};\n\n    for(const n of names) out[n] = gl.getUniformLocation(prog, n);\n\n    return out;\n\n  }\n\n  function initGL(){\n\n    gl = canvas.getContext('webgl2', {\n\n      alpha:false, depth:false, stencil:false,\n\n      antialias:false, desynchronized:true,\n\n      premultipliedAlpha:false, preserveDrawingBuffer:false\n\n    });\n\n    if(!gl) return false;\n\n    program = createProgram(gl, VERT, FRAG);\n\n    gl.useProgram(program);\n\n    uniforms = getUniformLocations(gl, program, [\n\n      'u_canvasSize', 'u_zoom','u_tex0','u_tex1','u_mix',\n\n      'u_mode','u_exposure','u_invGamma'\n\n    ]);\n\n    // fullscreen quad\n\n    const quad = new Float32Array([\n\n      -1,-1, 0,0,\n\n       1,-1, 1,0,\n\n      -1, 1, 0,1,\n\n       1, 1, 1,1\n\n    ]);\n\n    vao = gl.createVertexArray();\n\n    gl.bindVertexArray(vao);\n\n    const vbo = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n\n    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(0);\n\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);\n\n    gl.enableVertexAttribArray(1);\n\n    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);\n\n    gl.uniform1i(uniforms.u_tex0, 0);\n\n    gl.uniform1i(uniforms.u_tex1, 1);\n\n    setViewport(width,height);\n\n    return true;\n\n  }\n\n  function init2D(){\n\n    ctx2d = canvas.getContext('2d', { desynchronized:true });\n\n    return !!ctx2d;\n\n  }\n\n  function setViewport(w,h){\n\n    if(gl){\n\n      gl.viewport(0,0,w,h);\n\n      gl.useProgram(program);\n\n      gl.uniform2f(uniforms.u_canvasSize, w, h);\n\n    }\n\n  }\n\n  function createTextureFromSource(src){\n\n    const tex = gl.createTexture();\n\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);\n\n    return tex;\n\n  }\n\n  function resampleBitmap(bitmap, maxShortSide){\n\n    if(!maxShortSide || maxShortSide<=0) return bitmap;\n\n    const sw = bitmap.width, sh = bitmap.height;\n\n    const shortSide = Math.min(sw, sh);\n\n    if(shortSide <= maxShortSide) return bitmap;\n\n    const scale = maxShortSide/shortSide;\n\n    const tw = Math.max(1, Math.round(sw*scale));\n\n    const th = Math.max(1, Math.round(sh*scale));\n\n    const oc = new OffscreenCanvas(tw, th);\n\n    const c2d = oc.getContext('2d', { desynchronized:true });\n\n    c2d.drawImage(bitmap, 0, 0, tw, th);\n\n    return oc;\n\n  }\n\n  function render(frame){\n\n    if(gl){\n\n      gl.useProgram(program);\n\n      gl.bindVertexArray(vao);\n\n      const N = Math.max(1, textures.length);\n\n      const i0 = frame % N;\n\n      const i1 = (i0 + 1) % N;\n\n      gl.activeTexture(gl.TEXTURE0);\n\n      gl.bindTexture(gl.TEXTURE_2D, textures[i0]);\n\n      gl.activeTexture(gl.TEXTURE1);\n\n      gl.bindTexture(gl.TEXTURE_2D, textures[i1]);\n\n      const mode = (effect==='passthrough')?0:(effect==='crossfade')?1:(effect==='multiply')?2:3;\n\n      gl.uniform1i(uniforms.u_mode, mode);\n\n      gl.uniform1f(uniforms.u_mix, (effect==='crossfade')?0.5:0.0);\n\n      gl.uniform1f(uniforms.u_exposure, exposure);\n\n      gl.uniform1f(uniforms.u_invGamma, 1.0/Math.max(0.01,gamma));\n\n      gl.uniform3f(uniforms.u_zoom, zoom.scale, zoom.panX, zoom.panY);\n\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n    } else if (ctx2d){\n\n      const N = Math.max(1, imagesMeta.length);\n\n      const i0 = frame % N;\n\n      const img = imagesMeta[i0];\n\n      ctx2d.clearRect(0,0,width,height);\n\n      ctx2d.save();\n\n      ctx2d.translate(width*0.5 + zoom.panX, height*0.5 + zoom.panY);\n\n      ctx2d.scale(zoom.scale, zoom.scale);\n\n      ctx2d.drawImage(img, -img.width*0.5, -img.height*0.5);\n\n      ctx2d.restore();\n\n    }\n\n  }\n\n  self.onmessage = async (e)=>{\n\n    const msg = e.data || {};\n\n    try{\n\n      switch(msg.type){\n\n        case 'init': {\n\n          canvas = msg.canvas || new OffscreenCanvas(msg.width||1, msg.height||1);\n\n          width = msg.width||1; height = msg.height||1; fps = msg.fps||24;\n\n          if(!initGL()){\n\n            if(!init2D()) throw new Error('No WebGL2 or 2D context available.');\n\n          }\n\n          canvas.width = width; canvas.height = height;\n\n          setViewport(width, height);\n\n          self.postMessage({ type:'ready' });\n\n          break;\n\n        }\n\n        case 'resize': {\n\n          width = Math.max(1, msg.width|0);\n\n          height = Math.max(1, msg.height|0);\n\n          canvas.width = width; canvas.height = height;\n\n          if(gl) setViewport(width, height);\n\n          break;\n\n        }\n\n        case 'load-images': {\n\n          const ims = msg.bitmaps || [];\n\n          imagesMeta = [];\n\n          if(gl){\n\n            for(const t of textures) gl.deleteTexture(t);\n\n            textures = [];\n\n          }\n\n          const targetShort = 2048;\n\n          for(const bm of ims){\n\n            const src = (Math.min(bm.width, bm.height) > targetShort)\n\n              ? resampleBitmap(bm, targetShort)\n\n              : bm;\n\n            imagesMeta.push(src);\n\n            if(gl) textures.push(createTextureFromSource(src));\n\n          }\n\n          break;\n\n        }\n\n        case 'advance': {\n\n          frameCounter = msg.frame|0;\n\n          render(frameCounter);\n\n          break;\n\n        }\n\n        case 'seek': {\n\n          frameCounter = msg.frame|0;\n\n          render(frameCounter);\n\n          break;\n\n        }\n\n        case 'fps': {\n\n          fps = Math.max(1, Math.min(120, msg.fps|0));\n\n          break;\n\n        }\n\n        case 'params': {\n\n          const p = msg.params||{};\n\n          if(typeof p.effect==='string') effect = p.effect;\n\n          if(typeof p.exposure==='number') exposure = p.exposure;\n\n          if(typeof p.gamma==='number' && isFinite(p.gamma) && p.gamma>0) gamma = p.gamma;\n\n          break;\n\n        }\n\n        case 'zoom': {\n\n          const z = msg.zoom||{};\n\n          if(typeof z.scale==='number') zoom.scale = z.scale;\n\n          if(typeof z.panX==='number') zoom.panX = z.panX;\n\n          if(typeof z.panY==='number') zoom.panY = z.panY;\n\n          break;\n\n        }\n\n        default: break;\n\n      }\n\n    } catch(err){\n\n      self.postMessage({ type:'error', data:{ message: err?.message || String(err) }});\n\n    }\n\n  };\n\n  `;\n\n}\n\n// Create worker from Blob URL\n\nfunction createWorker() {\n\n  const src = buildWorkerSource();\n\n  const blob = new Blob([src], { type: 'application/javascript' });\n\n  const url = URL.createObjectURL(blob);\n\n  const w = new Worker(url, { type: 'module' });\n\n  // Revoke later when destroyed\n\n  w._blobUrl = url;\n\n  return w;\n\n}\n\n// Init engine on CodePen\n\nasync function initAnimationEngine(canvasEl, opts = {}) {\n\n  mainCanvas = canvasEl;\n\n  const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));\n\n  const rect = mainCanvas.getBoundingClientRect();\n\n  _canvasPixelWidth = Math.max(1, Math.floor(rect.width * dpr));\n\n  _canvasPixelHeight = Math.max(1, Math.floor(rect.height * dpr));\n\n  if ('transferControlToOffscreen' in mainCanvas) {\n\n    _offscreen = mainCanvas.transferControlToOffscreen();\n\n  }\n\n  _worker = createWorker();\n\n  _worker.onmessage = (e) => {\n\n    const { type, data } = e.data || {};\n\n    if (type === 'ready') _ready = true;\n\n    else if (type === 'error') console.error('[worker]', data?.message || data);\n\n  };\n\n  // Observe canvas size changes\n\n  const ro = new ResizeObserver(() => {\n\n    const r = mainCanvas.getBoundingClientRect();\n\n    const d = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));\n\n    const w = Math.max(1, Math.floor(r.width * d));\n\n    const h = Math.max(1, Math.floor(r.height * d));\n\n    if (w !== _canvasPixelWidth || h !== _canvasPixelHeight) {\n\n      _canvasPixelWidth = w; _canvasPixelHeight = h;\n\n      _worker?.postMessage({ type: 'resize', width: w, height: h });\n\n    }\n\n  });\n\n  ro.observe(mainCanvas);\n\n  // Send init to worker\n\n  _worker.postMessage({\n\n    type: 'init',\n\n    canvas: _offscreen ?? null,\n\n    width: _canvasPixelWidth,\n\n    height: _canvasPixelHeight,\n\n    fps: _targetFps\n\n  }, _offscreen ? [_offscreen] : []);\n\n}\n\nasync function _toBitmap(src) {\n\n  const res = await fetch(src, { mode: 'cors', cache: 'force-cache' });\n\n  const blob = await res.blob();\n\n  return await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n\n}\n\nasync function loadImagesFromUrls(urls) {\n\n  if (!_ready) await new Promise(r => {\n\n    const id = setInterval(() => { if (_ready) { clearInterval(id); r(); } }, 10);\n\n  });\n\n  const bitmaps = [];\n\n  for (const url of urls) bitmaps.push(await _toBitmap(url));\n\n  _bitmaps = bitmaps;\n\n  _worker.postMessage({ type: 'load-images', bitmaps }, bitmaps);\n\n  images.clear();\n\n  urls.forEach((u, i) => images.set(`img_${i}`, u));\n\n}\n\nfunction _tick(ts) {\n\n  if (!playing) return;\n\n  const step = 1000 / _targetFps;\n\n  if (ts - _lastT >= step) {\n\n    _lastT = ts;\n\n    currentFrame++;\n\n    _worker.postMessage({ type: 'advance', frame: currentFrame, timestamp: ts });\n\n  }\n\n  _rAF = requestAnimationFrame(_tick);\n\n}\n\nfunction play() {\n\n  if (!_ready || playing) return;\n\n  playing = true;\n\n  _lastT = performance.now();\n\n  _rAF = requestAnimationFrame(_tick);\n\n}\n\nfunction pause() {\n\n  playing = false;\n\n  if (_rAF) cancelAnimationFrame(_rAF);\n\n}\n\nfunction setFps(fps) {\n\n  const f = Math.max(1, Math.min(120, Math.floor(fps)));\n\n  _targetFps = f;\n\n  animationSpeed = 1000 / f;\n\n  _worker.postMessage({ type: 'fps', fps: f });\n\n}\n\nfunction setParams(params) {\n\n  _worker.postMessage({ type: 'params', params: { ...params } });\n\n}\n\nfunction setZoom({ scale = 1, panX = 0, panY = 0 } = {}) {\n\n  zoomState.scale = +scale || 1;\n\n  zoomState.panX = +panX || 0;\n\n  zoomState.panY = +panY || 0;\n\n  _worker.postMessage({ type: 'zoom', zoom: { ...zoomState } });\n\n}\n\n// ---------- Wire up demo controls ----------\n\n(async function main(){\n\n  const canvas = document.getElementById('main');\n\n  await initAnimationEngine(canvas, { fps: 24 });\n\n  // Replace with your own CORS-allowed images\n\n  const demoImgs = [\n\n    'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?w=1024&q=80&auto=format',\n\n    'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?w=1024&q=80&auto=format',\n\n    'https://images.unsplash.com/photo-1500534623283-312aade485b7?w=1024&q=80&auto=format'\n\n  ];\n\n  await loadImagesFromUrls(demoImgs);\n\n  // Controls\n\n  document.getElementById('btnPlay').onclick = play;\n\n  document.getElementById('btnPause').onclick = pause;\n\n  const fpsInput = document.getElementById('fps');\n\n  fpsInput.oninput = () => setFps(+fpsInput.value || 24);\n\n  const effectSel = document.getElementById('effect');\n\n  const gammaInput = document.getElementById('gamma');\n\n  const exposureInput = document.getElementById('exposure');\n\n  const scaleInput = document.getElementById('scale');\n\n  const panXInput = document.getElementById('panX');\n\n  const panYInput = document.getElementById('panY');\n\n  function pushParams(){\n\n    setParams({\n\n      effect: effectSel.value,\n\n      gamma: parseFloat(gammaInput.value) || 1.0,\n\n      exposure: parseFloat(exposureInput.value) || 0\n\n    });\n\n  }\n\n  function pushZoom(){\n\n    setZoom({\n\n      scale: parseFloat(scaleInput.value) || 1,\n\n      panX: parseFloat(panXInput.value) || 0,\n\n      panY: parseFloat(panYInput.value) || 0\n\n    });\n\n  }\n\n  effectSel.oninput = pushParams;\n\n  gammaInput.oninput = pushParams;\n\n  exposureInput.oninput = pushParams;\n\n  scaleInput.oninput = pushZoom;\n\n  panXInput.oninput = pushZoom;\n\n  panYInput.oninput = pushZoom;\n\n  pushParams();\n\n  play();\n\n})();";
export const TOOL_FUNCTIONS = Object.fromEntries(TOOL_FUNCTION_NAMES.map((n) => [n, null]));
