// Extracted metadata module (safe text representation)
export const TOOL_SOURCE_PATH = "toIntegrate/index (1).html";
export const TOOL_EXTRACTION_MODE = "regex-only";
export const TOOL_FUNCTION_NAMES = [
  "setup",
  "draw",
  "step"
];
export const TOOL_REGEX_FUNCTION_NAMES = [
  "setup",
  "draw",
  "step"
];
export const TOOL_LLM_FUNCTION_NAMES = [];
export const TOOL_LLM_CAPABILITIES = [];
export const TOOL_LLM_NOTES = "";
export const TOOL_SOURCE_TEXT = "\n\n// ============================================================\n// CONFIG\n// ============================================================\nconst CONFIG = {\n  canvas: { baseW: 600, baseH: 700, scale: 0.5, background: \"#ffffff\", padding: 5 },\n  engine: { mode: \"flow\", orientation: \"horizontal\" },\n  flow: {\n    lineSpacing: 6, oscAmplitude: 2.5, oscFreq: 1.0,\n    sampleStep: 1.0, baseSpeed: 0.5, phaseIncrement: 0, stopSpawnFrame: 0\n  },\n  static: {\n    lineSpacing: 6, maxAmplitude: 3.0, frequency: 60, sampleStep: 1.0,\n    phaseOffset: 0, phaseIncrement: 0, ampCurve: \"linear\", ampCurveStrength: 2.0\n  },\n  serpentine: {\n    spawnRate: 20, oscSpeed: 1, oscTopPercent: 0, oscBottomPercent: 100, baseSpeed: 0.3\n  },\n  drag: { dragLight: 0.0, dragDark: 0.5, curveType: \"linear\", curveStrength: 2.0 },\n  tension: { baseTension: 0.05, brightBoost: 0.15, brightThreshold: 0.5, maxSegmentLength: 10 },\n  source: { fitMode: \"contain\", invertLuminance: false },\n  render: { strokeHex: \"#000000\", strokeWeight: 1.0, alpha: 255 },\n  animation: { drawProgress: 1.0, totalFrames: 120, holdFrames: 30, easing: \"easeOut\", fps: 30 }\n};\n\n// ============================================================\n// LINE POINT\n// ============================================================\nclass LinePoint {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.lum = 0.5;\n    this.onBorder = false;\n    this.borderPhase = null;\n  }\n}\n\n// ============================================================\n// LUMINANCE FIELD\n// ============================================================\nclass LuminanceField {\n  constructor(canvasW, canvasH) {\n    this.canvasW = canvasW;\n    this.canvasH = canvasH;\n    this.data = null;\n    this.imgW = 0;\n    this.imgH = 0;\n    this.fit = null;\n  }\n\n  updateFromDomImage(domImg, fitMode) {\n    const tc = document.createElement(\"canvas\");\n    tc.width = domImg.width;\n    tc.height = domImg.height;\n    const ctx = tc.getContext(\"2d\");\n    ctx.drawImage(domImg, 0, 0);\n    const px = ctx.getImageData(0, 0, domImg.width, domImg.height).data;\n    this.imgW = domImg.width;\n    this.imgH = domImg.height;\n    this.data = new Float32Array(this.imgW * this.imgH);\n    for (let i = 0; i < this.imgW * this.imgH; i++) {\n      const idx = i * 4;\n      this.data[i] = 0.2126 * (px[idx] / 255) + 0.7152 * (px[idx+1] / 255) + 0.0722 * (px[idx+2] / 255);\n    }\n    this.fit = fitMode === \"cover\"\n      ? FitMapper.cover(this.imgW, this.imgH, this.canvasW, this.canvasH)\n      : FitMapper.contain(this.imgW, this.imgH, this.canvasW, this.canvasH);\n  }\n\n  lumAt(cx, cy) {\n    if (!this.data || !this.fit) return 0.5;\n    const src = this.fit.canvasToSource(cx, cy);\n    if (!src) return 0.5;\n    const ix = Math.max(0, Math.min(this.imgW - 1, Math.floor(src.x)));\n    const iy = Math.max(0, Math.min(this.imgH - 1, Math.floor(src.y)));\n    return this.data[iy * this.imgW + ix];\n  }\n}\n\n// ============================================================\n// FIT MAPPER\n// ============================================================\nclass FitMapper {\n  constructor(srcW, srcH, dstX, dstY, drawW, drawH) {\n    this.srcW = srcW; this.srcH = srcH;\n    this.dstX = dstX; this.dstY = dstY;\n    this.drawW = drawW; this.drawH = drawH;\n  }\n\n  canvasToSource(cx, cy) {\n    if (cx < this.dstX || cx > this.dstX + this.drawW ||\n        cy < this.dstY || cy > this.dstY + this.drawH) return null;\n    const u = Math.max(0, Math.min(1, (cx - this.dstX) / this.drawW));\n    const v = Math.max(0, Math.min(1, (cy - this.dstY) / this.drawH));\n    return { x: u * (this.srcW - 1), y: v * (this.srcH - 1) };\n  }\n\n  static _calc(srcW, srcH, dstW, dstH, cover) {\n    const sa = srcW / srcH, da = dstW / dstH;\n    let dw, dh;\n    if (cover ? (sa > da) : (sa < da)) { dh = dstH; dw = dstH * sa; }\n    else { dw = dstW; dh = dstW / sa; }\n    return new FitMapper(srcW, srcH, (dstW - dw) / 2, (dstH - dh) / 2, dw, dh);\n  }\n\n  static cover(sw, sh, dw, dh) { return FitMapper._calc(sw, sh, dw, dh, true); }\n  static contain(sw, sh, dw, dh) { return FitMapper._calc(sw, sh, dw, dh, false); }\n}\n\n// ============================================================\n// DRAG MODEL\n// ============================================================\nclass DragModel {\n  static calculate(lum, dc) {\n    let t = 1 - lum;\n    switch (dc.curveType) {\n      case \"exponential\": t = Math.pow(t, dc.curveStrength); break;\n      case \"logarithmic\": t = Math.log(1 + t * (Math.pow(Math.E, dc.curveStrength) - 1)) / dc.curveStrength; break;\n      case \"sigmoid\": { const k = dc.curveStrength * 2; t = 1 / (1 + Math.exp(-k * (t - 0.5))); break; }\n    }\n    return dc.dragLight + (dc.dragDark - dc.dragLight) * t;\n  }\n}\n\n// ============================================================\n// CURVE UTIL\n// ============================================================\nclass CurveUtil {\n  static apply(t, type, str) {\n    switch (type) {\n      case \"exponential\": return Math.pow(t, str);\n      case \"logarithmic\": return Math.log(1 + t * (Math.pow(Math.E, str) - 1)) / str;\n      case \"sigmoid\": { const k = str * 2; return 1 / (1 + Math.exp(-k * (t - 0.5))); }\n      default: return t;\n    }\n  }\n}\n\n// ============================================================\n// EASING\n// ============================================================\nclass Easing {\n  static apply(t, type) {\n    switch (type) {\n      case \"easeIn\": return t * t;\n      case \"easeOut\": return t * (2 - t);\n      case \"easeInOut\": return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      default: return t;\n    }\n  }\n}\n\n// ============================================================\n// TENSION SOLVER (shared)\n// ============================================================\nclass TensionSolver {\n  static apply(points, tc) {\n    if (points.length < 3) return;\n    const { baseTension, brightBoost, brightThreshold, maxSegmentLength } = tc;\n    const len = points.length;\n    const nx = new Float32Array(len);\n    const ny = new Float32Array(len);\n    for (let i = 0; i < len; i++) { nx[i] = points[i].x; ny[i] = points[i].y; }\n\n    for (let i = 1; i < len - 1; i++) {\n      const prev = points[i-1], curr = points[i], next = points[i+1];\n      if (curr.onBorder) continue;\n      let tension = baseTension;\n      const lum = curr.lum !== undefined ? curr.lum : 0.5;\n      if (lum > brightThreshold) tension += brightBoost * ((lum - brightThreshold) / (1 - brightThreshold));\n      nx[i] = curr.x + ((prev.x + next.x) / 2 - curr.x) * tension;\n      ny[i] = curr.y + ((prev.y + next.y) / 2 - curr.y) * tension;\n    }\n    for (let i = 1; i < len - 1; i++) {\n      if (!points[i].onBorder) { points[i].x = nx[i]; points[i].y = ny[i]; }\n    }\n    for (let i = 1; i < len; i++) {\n      const dx = points[i].x - points[i-1].x;\n      const dy = points[i].y - points[i-1].y;\n      const d = Math.sqrt(dx*dx + dy*dy);\n      if (d > maxSegmentLength) {\n        const s = maxSegmentLength / d;\n        points[i].x = points[i-1].x + dx * s;\n        points[i].y = points[i-1].y + dy * s;\n      }\n    }\n  }\n}\n\n// ============================================================\n// FLOW WAVE FRONT \u2014 a complete line that sweeps perpendicular\n// to itself. Each point receives independent luminance drag.\n// Sine displacement is baked into initial flow position.\n// ============================================================\nclass FlowWaveFront {\n  constructor(startFlowPos, lineStart, lineEnd, sampleStep, amplitude, frequency, phase) {\n    this.points = [];\n    this.complete = false;\n    this._displayH = null;\n    this._displayV = null;\n    this._dirty = true;\n    for (let s = lineStart; s <= lineEnd; s += sampleStep) {\n      const sineDisp = Math.sin(s * frequency * 0.01 + phase) * amplitude;\n      this.points.push({\n        linePos: s,\n        flowPos: startFlowPos + sineDisp,\n        lum: 0.5\n      });\n    }\n    // Pre-allocate display arrays\n    this._displayH = new Array(this.points.length);\n    this._displayV = new Array(this.points.length);\n    for (let i = 0; i < this.points.length; i++) {\n      this._displayH[i] = { x: 0, y: 0 };\n      this._displayV[i] = { x: 0, y: 0 };\n    }\n  }\n\n  update(lumField, dragCfg, baseSpeed, isHoriz, invertLum, farEdge) {\n    if (this.complete) return;\n    let allDone = true;\n    for (const p of this.points) {\n      if (p.flowPos >= farEdge) continue;\n      const cx = isHoriz ? p.linePos : p.flowPos;\n      const cy = isHoriz ? p.flowPos : p.linePos;\n      let lum = lumField.lumAt(cx, cy);\n      if (invertLum) lum = 1 - lum;\n      p.lum = lum;\n      const drag = DragModel.calculate(lum, dragCfg);\n      p.flowPos += baseSpeed * (1 - drag);\n      if (p.flowPos >= farEdge) p.flowPos = farEdge;\n      else allDone = false;\n    }\n    this._dirty = true;\n    if (allDone) this.complete = true;\n  }\n\n  getDisplayPoints(isHoriz) {\n    if (!this._dirty) return isHoriz ? this._displayH : this._displayV;\n    for (let i = 0; i < this.points.length; i++) {\n      const p = this.points[i];\n      this._displayH[i].x = p.linePos;\n      this._displayH[i].y = p.flowPos;\n      this._displayV[i].x = p.flowPos;\n      this._displayV[i].y = p.linePos;\n    }\n    this._dirty = false;\n    return isHoriz ? this._displayH : this._displayV;\n  }\n}\n\n// ============================================================\n// WAVE FRONT FLOW ENGINE\n// Spawns wave fronts at start edge, each sweeps perpendicular\n// with per-point luminance drag. Dark areas \u2192 fronts bunch up.\n// Runs indefinitely \u2014 frame budget is controlled externally.\n// ============================================================\nclass WaveFrontFlowEngine {\n  constructor() {\n    this.waveFronts = [];\n    this.complete = false;\n    this.framesSinceSpawn = Infinity;\n    this.frontIndex = 0;\n    this.simFrame = 0;\n    this._gcHead = 0; // index of first active front\n  }\n\n  init(canvasW, canvasH, config) {\n    this.waveFronts = [];\n    this.complete = false;\n    this.framesSinceSpawn = Infinity;\n    this.frontIndex = 0;\n    this.simFrame = 0;\n    this._gcHead = 0;\n\n    const isHoriz = config.engine.orientation === \"horizontal\";\n    this.isHoriz = isHoriz;\n    const pad = config.canvas.padding;\n    this.lineStart = pad;\n    this.lineEnd = isHoriz ? canvasW - pad : canvasH - pad;\n    this.flowStart = pad;\n    this.farEdge = isHoriz ? canvasH - pad : canvasW - pad;\n  }\n\n  update(lumField, config) {\n    if (this.complete) return;\n\n    const fc = config.flow;\n    const spawnInterval = Math.max(1, Math.round(fc.lineSpacing / Math.max(0.01, fc.baseSpeed)));\n    const stopFrame = fc.stopSpawnFrame;\n    const spawningAllowed = stopFrame <= 0 || this.simFrame < stopFrame;\n\n    // Spawn new wave front at regular intervals\n    this.framesSinceSpawn++;\n    if (this.framesSinceSpawn >= spawnInterval && spawningAllowed) {\n      const phase = this.frontIndex * fc.phaseIncrement;\n      const wf = new FlowWaveFront(\n        this.flowStart, this.lineStart, this.lineEnd,\n        fc.sampleStep, fc.oscAmplitude, fc.oscFreq, phase\n      );\n      this.waveFronts.push(wf);\n      this.framesSinceSpawn = 0;\n      this.frontIndex++;\n    }\n\n    // Update active wave fronts (skip GC'd ones)\n    for (let i = this._gcHead; i < this.waveFronts.length; i++) {\n      this.waveFronts[i].update(lumField, config.drag, fc.baseSpeed, this.isHoriz,\n        config.source.invertLuminance, this.farEdge);\n    }\n\n    // GC: advance head past completed fronts (O(1) per frame)\n    while (this._gcHead < this.waveFronts.length && this.waveFronts[this._gcHead].complete) {\n      this.waveFronts[this._gcHead] = null; // release ref\n      this._gcHead++;\n    }\n\n    // Compact when half the array is dead refs\n    if (this._gcHead > 500) {\n      this.waveFronts = this.waveFronts.slice(this._gcHead);\n      this._gcHead = 0;\n    }\n\n    // Auto-complete: spawning stopped AND all fronts swept off\n    if (!spawningAllowed && this._gcHead >= this.waveFronts.length) {\n      this.complete = true;\n    }\n\n    this.simFrame++;\n  }\n\n  _activeFronts() {\n    const active = [];\n    for (let i = this._gcHead; i < this.waveFronts.length; i++) {\n      if (this.waveFronts[i]) active.push(this.waveFronts[i]);\n    }\n    return active;\n  }\n\n  getDrawableLines(progress) {\n    const active = this._activeFronts();\n    if (active.length === 0) return [];\n    const count = progress >= 1 ? active.length : Math.max(1, Math.ceil(active.length * progress));\n    const result = [];\n    for (let i = 0; i < count; i++) {\n      result.push(active[i].getDisplayPoints(this.isHoriz));\n    }\n    return result;\n  }\n\n  getAllPoints() {\n    const active = this._activeFronts();\n    const result = [];\n    for (let i = 0; i < active.length; i++) {\n      result.push(active[i].getDisplayPoints(this.isHoriz));\n    }\n    return result;\n  }\n}\n\n// ============================================================\n// PARALLEL STATIC ENGINE\n// ============================================================\nclass ParallelStaticEngine {\n  constructor() { this.lines = []; }\n\n  generate(lumField, config, canvasW, canvasH) {\n    this.lines = [];\n    const pad = config.canvas.padding;\n    const sc = config.static;\n    const invert = config.source.invertLuminance;\n    const isHoriz = config.engine.orientation === \"horizontal\";\n    const pLen = isHoriz ? canvasW : canvasH;\n    const cLen = isHoriz ? canvasH : canvasW;\n    const n = Math.max(1, Math.floor((cLen - 2 * pad) / sc.lineSpacing) + 1);\n\n    for (let li = 0; li < n; li++) {\n      const base = pad + li * sc.lineSpacing;\n      const ph = sc.phaseOffset + li * sc.phaseIncrement;\n      const pts = [];\n      for (let s = pad; s <= pLen - pad; s += sc.sampleStep) {\n        const cx = isHoriz ? s : base;\n        const cy = isHoriz ? base : s;\n        let lum = lumField.lumAt(cx, cy);\n        if (invert) lum = 1 - lum;\n        const curved = CurveUtil.apply(1 - lum, sc.ampCurve, sc.ampCurveStrength);\n        const disp = sc.maxAmplitude * curved * Math.sin((s / pLen) * sc.frequency + ph);\n        if (isHoriz) pts.push({ x: s, y: base + disp });\n        else pts.push({ x: base + disp, y: s });\n      }\n      this.lines.push(pts);\n    }\n  }\n\n  getDrawableLines(progress) {\n    if (progress >= 1) return this.lines;\n    const total = this.lines.reduce((s, l) => s + l.length, 0);\n    const target = Math.floor(total * progress);\n    const result = [];\n    let counted = 0;\n    for (const line of this.lines) {\n      const rem = target - counted;\n      if (rem <= 0) break;\n      if (rem >= line.length) { result.push(line); counted += line.length; }\n      else { result.push(line.slice(0, rem)); counted += rem; }\n    }\n    return result;\n  }\n}\n\n// ============================================================\n// SERPENTINE ENGINE\n// ============================================================\nclass SerpentineEngine {\n  constructor(canvasW, canvasH, padding) {\n    this.canvasW = canvasW;\n    this.canvasH = canvasH;\n    this.padding = padding;\n    this.points = [];\n    this.spawnPhase = 0;\n    this.complete = false;\n    this.startY = null;\n  }\n\n  update(lumField, dragCfg, tensionCfg, serpCfg, invertLum, canvasW, canvasH) {\n    if (this.complete) return;\n    this.canvasW = canvasW;\n    this.canvasH = canvasH;\n    const pad = this.padding;\n    const { baseSpeed, spawnRate, oscSpeed } = serpCfg;\n    const oscTop = pad + (serpCfg.oscTopPercent / 100) * (canvasH - 2 * pad);\n    const oscBottom = pad + (serpCfg.oscBottomPercent / 100) * (canvasH - 2 * pad);\n    const amp = (oscBottom - oscTop) / 2;\n    const center = (oscTop + oscBottom) / 2;\n\n    for (let i = 0; i < spawnRate; i++) {\n      const y = center + Math.sin(this.spawnPhase) * amp;\n      this.points.push(new LinePoint(pad, y));\n      if (this.startY === null) this.startY = y;\n      this.spawnPhase += oscSpeed * 0.01;\n    }\n\n    for (const p of this.points) {\n      if (p.onBorder) continue;\n      let lum = lumField.lumAt(p.x, p.y);\n      if (invertLum) lum = 1 - lum;\n      p.lum = lum;\n      p.x += baseSpeed * (1 - DragModel.calculate(lum, dragCfg));\n      if (p.x >= canvasW - pad) { p.x = canvasW - pad; p.onBorder = true; p.borderPhase = 'right'; }\n    }\n\n    const speed = baseSpeed * 2;\n    const right = canvasW - pad, bottom = canvasH - pad;\n    for (const p of this.points) {\n      if (!p.onBorder) continue;\n      switch (p.borderPhase) {\n        case 'right': p.y += speed; if (p.y >= bottom) { p.y = bottom; p.borderPhase = 'bottom'; } break;\n        case 'bottom': p.x -= speed; if (p.x <= pad) { p.x = pad; p.borderPhase = 'left'; } break;\n        case 'left': p.y -= speed; if (p.y <= this.startY) { p.y = this.startY; p.borderPhase = 'done'; } break;\n      }\n    }\n\n    TensionSolver.apply(this.points, tensionCfg);\n\n    while (this.points.length > 0 && this.points[0].borderPhase === 'done') this.points.shift();\n    if (this.points.length === 0 && this.startY !== null) this.complete = true;\n  }\n}\n\n// ============================================================\n// RENDERER\n// ============================================================\nclass Renderer {\n  constructor() {\n    this._cachedColor = null;\n    this._lastHex = null;\n    this._lastAlpha = null;\n  }\n\n  _sync(rc) {\n    if (this._lastHex !== rc.strokeHex || this._lastAlpha !== rc.alpha) {\n      this._cachedColor = color(rc.strokeHex);\n      this._cachedColor.setAlpha(rc.alpha);\n      this._lastHex = rc.strokeHex;\n      this._lastAlpha = rc.alpha;\n    }\n    stroke(this._cachedColor);\n    strokeWeight(rc.strokeWeight);\n    noFill();\n  }\n\n  drawLines(lines, rc) {\n    this._sync(rc);\n    for (const pts of lines) {\n      if (pts.length < 2) continue;\n      beginShape();\n      for (const p of pts) vertex(p.x, p.y);\n      endShape();\n    }\n  }\n\n  drawSerpentine(engine, rc) {\n    if (engine.points.length < 2) return;\n    this._sync(rc);\n    beginShape();\n    for (const p of engine.points) vertex(p.x, p.y);\n    endShape();\n  }\n}\n\n// ============================================================\n// SVG BUILDER\n// ============================================================\nclass SvgBuilder {\n  static build(lines, w, h, bg, sc, sw, alpha) {\n    const op = (alpha / 255).toFixed(3);\n    const pathParts = [];\n    for (const line of lines) {\n      if (line.length < 2) continue;\n      const coords = [`M${line[0].x.toFixed(2)},${line[0].y.toFixed(2)}`];\n      for (let i = 1; i < line.length; i++) {\n        coords.push(`L${line[i].x.toFixed(2)},${line[i].y.toFixed(2)}`);\n      }\n      pathParts.push(`<path d=\"${coords.join('')}\" fill=\"none\" stroke=\"${sc}\" stroke-width=\"${sw}\" opacity=\"${op}\"/>`);\n    }\n    return `<?xml version=\"1.0\"?>\\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${w}\" height=\"${h}\" viewBox=\"0 0 ${w} ${h}\">\\n<rect width=\"${w}\" height=\"${h}\" fill=\"${bg}\"/>\\n${pathParts.join('\\n')}\\n</svg>`;\n  }\n}\n\n// ============================================================\n// EXPORT MANAGER\n// ============================================================\nclass ExportManager {\n  static exportPng() { saveCanvas('serpentine', 'png'); }\n\n  static exportSvg(lines, w, h, bg, sc, sw, alpha) {\n    const blob = new Blob([SvgBuilder.build(lines, w, h, bg, sc, sw, alpha)], { type: 'image/svg+xml' });\n    const a = document.createElement('a');\n    a.href = URL.createObjectURL(blob);\n    a.download = 'serpentine.svg';\n    a.click();\n    URL.revokeObjectURL(a.href);\n  }\n\n  static async recordWebM(app, onProgress, onComplete) {\n    const cfg = app.config;\n    const totalF = cfg.animation.totalFrames;\n    const holdF = cfg.animation.holdFrames;\n    const fps = cfg.animation.fps;\n    const easing = cfg.animation.easing;\n    const allF = totalF + holdF;\n    const mode = cfg.engine.mode;\n\n    const cvs = document.querySelector('#canvas-container canvas');\n    if (!cvs) { onComplete(null); return; }\n\n    const stream = cvs.captureStream(0);\n    const rec = new MediaRecorder(stream, {\n      mimeType: 'video/webm; codecs=vp9',\n      videoBitsPerSecond: 8000000\n    });\n    const chunks = [];\n    rec.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };\n    rec.onstop = () => {\n      const blob = new Blob(chunks, { type: 'video/webm' });\n      const a = document.createElement('a');\n      a.href = URL.createObjectURL(blob);\n      a.download = 'serpentine.webm';\n      a.click();\n      URL.revokeObjectURL(a.href);\n      onComplete(blob);\n    };\n\n    rec.start();\n    const wasPaused = app.paused;\n    app.paused = true;\n\n    if (mode === \"flow\") {\n      app.initFlowEngine();\n      for (let f = 0; f < allF; f++) {\n        if (f < totalF && !app.flowEngine.complete) {\n          app.flowEngine.update(app.lumField, cfg);\n        }\n        app.renderFrame();\n        stream.getVideoTracks()[0].requestFrame();\n        onProgress(f / allF);\n        await new Promise(r => setTimeout(r, 1000 / fps));\n        // Early exit if engine complete and we've held enough\n        if (app.flowEngine.complete && f >= totalF) break;\n      }\n    } else if (mode === \"static\") {\n      app.staticEngine.generate(app.lumField, cfg, app.canvasW, app.canvasH);\n      for (let f = 0; f < allF; f++) {\n        cfg.animation.drawProgress = f < totalF\n          ? Easing.apply(f / Math.max(1, totalF - 1), easing) : 1.0;\n        app.renderFrame();\n        stream.getVideoTracks()[0].requestFrame();\n        onProgress(f / allF);\n        await new Promise(r => setTimeout(r, 1000 / fps));\n      }\n      cfg.animation.drawProgress = 1.0;\n    } else {\n      app.initSerpentineEngine();\n      for (let f = 0; f < allF; f++) {\n        if (f < totalF) {\n          app.serpentineEngine.update(app.lumField, cfg.drag, cfg.tension, cfg.serpentine,\n            cfg.source.invertLuminance, app.canvasW, app.canvasH);\n        }\n        app.renderFrame();\n        stream.getVideoTracks()[0].requestFrame();\n        onProgress(f / allF);\n        await new Promise(r => setTimeout(r, 1000 / fps));\n      }\n    }\n\n    rec.stop();\n    app.paused = wasPaused;\n  }\n}\n\n// ============================================================\n// APP\n// ============================================================\nclass App {\n  constructor(config) {\n    this.config = config;\n    this.lumField = null;\n    this.flowEngine = null;\n    this.staticEngine = null;\n    this.serpentineEngine = null;\n    this.renderer = null;\n    this.imageReady = false;\n    this.paused = false;\n    this.sourceImage = null;\n    this.canvasW = 600;\n    this.canvasH = 700;\n    this._staticDirty = true;\n  }\n\n  setup() {\n    const canvas = createCanvas(this.config.canvas.baseW, this.config.canvas.baseH);\n    canvas.parent(\"canvas-container\");\n    background(this.config.canvas.background);\n    this.renderer = new Renderer();\n    this.flowEngine = new WaveFrontFlowEngine();\n    this.staticEngine = new ParallelStaticEngine();\n  }\n\n  loadImage(dataUrl, onComplete) {\n    const img = new Image();\n    img.onload = () => {\n      this.sourceImage = img;\n      this._rebuildCanvas();\n      onComplete?.(this.canvasW, this.canvasH);\n    };\n    img.src = dataUrl;\n  }\n\n  _rebuildCanvas() {\n    if (!this.sourceImage) return;\n    const c = this.config;\n    this.canvasW = Math.round(this.sourceImage.width * c.canvas.scale);\n    this.canvasH = Math.round(this.sourceImage.height * c.canvas.scale);\n    resizeCanvas(this.canvasW, this.canvasH);\n    background(c.canvas.background);\n    this.lumField = new LuminanceField(this.canvasW, this.canvasH);\n    this.lumField.updateFromDomImage(this.sourceImage, c.source.fitMode);\n    this._initCurrentEngine();\n    this.imageReady = true;\n  }\n\n  _initCurrentEngine() {\n    const m = this.config.engine.mode;\n    if (m === \"flow\") this.initFlowEngine();\n    else if (m === \"static\") this._staticDirty = true;\n    else this.initSerpentineEngine();\n  }\n\n  initFlowEngine() {\n    this.flowEngine = new WaveFrontFlowEngine();\n    this.flowEngine.init(this.canvasW, this.canvasH, this.config);\n  }\n\n  initSerpentineEngine() {\n    this.serpentineEngine = new SerpentineEngine(this.canvasW, this.canvasH, this.config.canvas.padding);\n  }\n\n  rescale(s) {\n    this.config.canvas.scale = s;\n    if (this.sourceImage) { this._rebuildCanvas(); return { w: this.canvasW, h: this.canvasH }; }\n    return null;\n  }\n\n  reset() { if (this.imageReady) this._initCurrentEngine(); }\n  setPaused(p) { this.paused = p; }\n  flagStaticDirty() { this._staticDirty = true; }\n\n  draw() {\n    const c = this.config;\n    background(c.canvas.background);\n    if (!this.imageReady || !this.lumField) return;\n\n    const m = c.engine.mode;\n    if (m === \"flow\") {\n      if (!this.paused && this.flowEngine) this.flowEngine.update(this.lumField, c);\n      if (this.flowEngine) this.renderer.drawLines(this.flowEngine.getDrawableLines(c.animation.drawProgress), c.render);\n    } else if (m === \"static\") {\n      if (this._staticDirty) { this.staticEngine.generate(this.lumField, c, this.canvasW, this.canvasH); this._staticDirty = false; }\n      this.renderer.drawLines(this.staticEngine.getDrawableLines(c.animation.drawProgress), c.render);\n    } else {\n      if (!this.paused && this.serpentineEngine) {\n        this.serpentineEngine.update(this.lumField, c.drag, c.tension, c.serpentine, c.source.invertLuminance, this.canvasW, this.canvasH);\n      }\n      if (this.serpentineEngine) this.renderer.drawSerpentine(this.serpentineEngine, c.render);\n    }\n  }\n\n  renderFrame() {\n    const c = this.config;\n    background(c.canvas.background);\n    if (!this.imageReady || !this.lumField) return;\n    const m = c.engine.mode;\n    if (m === \"flow\" && this.flowEngine) this.renderer.drawLines(this.flowEngine.getDrawableLines(c.animation.drawProgress), c.render);\n    else if (m === \"static\") this.renderer.drawLines(this.staticEngine.getDrawableLines(c.animation.drawProgress), c.render);\n    else if (this.serpentineEngine) this.renderer.drawSerpentine(this.serpentineEngine, c.render);\n  }\n\n  getCurrentLines() {\n    const m = this.config.engine.mode;\n    if (m === \"flow\" && this.flowEngine) return this.flowEngine.getAllPoints();\n    if (m === \"static\") return this.staticEngine.getDrawableLines(this.config.animation.drawProgress);\n    if (this.serpentineEngine) return [this.serpentineEngine.points];\n    return [];\n  }\n}\n\n// ============================================================\n// UI CONTROLLER\n// ============================================================\nclass UIController {\n  constructor(config) {\n    this.config = config;\n    this._cache();\n    this._bind();\n    this._syncVis();\n    this.onImageLoad = null; this.onReset = null; this.onPauseToggle = null;\n    this.onScaleChange = null; this.onStaticChange = null;\n    this.onExportPng = null; this.onExportSvg = null;\n    this.onRecordWebM = null; this.onPreviewAnim = null;\n    this.paused = false;\n  }\n\n  _cache() {\n    this.dropzone = document.getElementById(\"dropzone\");\n    this.fileInput = document.getElementById(\"file-input\");\n    this.previewContainer = document.getElementById(\"preview-container\");\n    this.previewImg = document.getElementById(\"preview-img\");\n    this.fileName = document.getElementById(\"file-name\");\n    this.fileDims = document.getElementById(\"file-dims\");\n    this.btnPause = document.getElementById(\"btn-pause\");\n    this.btnReset = document.getElementById(\"btn-reset\");\n    this.statusEl = document.getElementById(\"status\");\n    this.recordTrack = document.getElementById(\"record-progress-track\");\n    this.recordFill = document.getElementById(\"record-progress-fill\");\n    this.modeButtons = document.querySelectorAll(\"#mode-toggle .mode-btn\");\n    this.panels = {\n      flow: document.getElementById(\"panel-flow\"),\n      static: document.getElementById(\"panel-static\"),\n      serpOsc: document.getElementById(\"panel-serp-osc\"),\n      drag: document.getElementById(\"panel-drag\"),\n      tension: document.getElementById(\"panel-tension\")\n    };\n    this.grpOrientation = document.getElementById(\"grp-orientation\");\n  }\n\n  _bind() {\n    this.dropzone.addEventListener(\"click\", () => this.fileInput.click());\n    this.fileInput.addEventListener(\"change\", e => this._handleFile(e.target.files[0]));\n    this.dropzone.addEventListener(\"dragover\", e => { e.preventDefault(); this.dropzone.classList.add(\"dragover\"); });\n    this.dropzone.addEventListener(\"dragleave\", () => this.dropzone.classList.remove(\"dragover\"));\n    this.dropzone.addEventListener(\"drop\", e => {\n      e.preventDefault(); this.dropzone.classList.remove(\"dragover\");\n      const f = e.dataTransfer.files[0];\n      if (f?.type.startsWith(\"image/\")) this._handleFile(f);\n    });\n    this.btnReset.addEventListener(\"click\", () => this.onReset?.());\n    this.btnPause.addEventListener(\"click\", () => this._togglePause());\n\n    this.modeButtons.forEach(btn => btn.addEventListener(\"click\", () => {\n      this.modeButtons.forEach(b => b.classList.remove(\"active\"));\n      btn.classList.add(\"active\");\n      this.config.engine.mode = btn.dataset.mode;\n      this._syncVis();\n      this.onReset?.();\n    }));\n\n    this._sel(\"ctrl-fit-mode\", v => { this.config.source.fitMode = v; this.onReset?.(); });\n    this._sel(\"ctrl-scale\", v => this.onScaleChange?.(parseFloat(v)));\n    this._sel(\"ctrl-orientation\", v => { this.config.engine.orientation = v; this.onReset?.(); });\n    this._chk(\"ctrl-invert\", v => { this.config.source.invertLuminance = v; this._flagAll(); });\n\n    this._rng(\"ctrl-flow-spacing\", \"val-flow-spacing\", v => { this.config.flow.lineSpacing = v; this.onReset?.(); });\n    this._rng(\"ctrl-flow-amplitude\", \"val-flow-amplitude\", v => { this.config.flow.oscAmplitude = v; this.onReset?.(); });\n    this._rng(\"ctrl-flow-freq\", \"val-flow-freq\", v => { this.config.flow.oscFreq = v; this.onReset?.(); });\n    this._rng(\"ctrl-flow-step\", \"val-flow-step\", v => { this.config.flow.sampleStep = v; this.onReset?.(); });\n    this._rng(\"ctrl-flow-speed\", \"val-flow-speed\", v => { this.config.flow.baseSpeed = v; });\n    this._rng(\"ctrl-flow-phase-inc\", \"val-flow-phase-inc\", v => { this.config.flow.phaseIncrement = v; this.onReset?.(); });\n    this._rng(\"ctrl-flow-stop-spawn\", \"val-flow-stop-spawn\", v => { this.config.flow.stopSpawnFrame = v; });\n\n    this._rng(\"ctrl-static-spacing\", \"val-static-spacing\", v => { this.config.static.lineSpacing = v; this._flagStatic(); });\n    this._rng(\"ctrl-static-amplitude\", \"val-static-amplitude\", v => { this.config.static.maxAmplitude = v; this._flagStatic(); });\n    this._rng(\"ctrl-static-freq\", \"val-static-freq\", v => { this.config.static.frequency = v; this._flagStatic(); });\n    this._rng(\"ctrl-static-step\", \"val-static-step\", v => { this.config.static.sampleStep = v; this._flagStatic(); });\n    this._rng(\"ctrl-static-phase\", \"val-static-phase\", v => { this.config.static.phaseOffset = v; this._flagStatic(); });\n    this._rng(\"ctrl-static-phase-inc\", \"val-static-phase-inc\", v => { this.config.static.phaseIncrement = v; this._flagStatic(); });\n    this._sel(\"ctrl-static-curve\", v => { this.config.static.ampCurve = v; this._flagStatic(); });\n    this._rng(\"ctrl-static-curve-str\", \"val-static-curve-str\", v => { this.config.static.ampCurveStrength = v; this._flagStatic(); });\n\n    this._rng(\"ctrl-serp-spawn\", \"val-serp-spawn\", v => { this.config.serpentine.spawnRate = v; });\n    this._rng(\"ctrl-serp-freq\", \"val-serp-freq\", v => { this.config.serpentine.oscSpeed = v; });\n    this._rng(\"ctrl-osc-top\", \"val-osc-top\", v => { this.config.serpentine.oscTopPercent = v; });\n    this._rng(\"ctrl-osc-bottom\", \"val-osc-bottom\", v => { this.config.serpentine.oscBottomPercent = v; });\n    this._rng(\"ctrl-serp-speed\", \"val-serp-speed\", v => { this.config.serpentine.baseSpeed = v; });\n\n    this._rng(\"ctrl-drag-light\", \"val-drag-light\", v => { this.config.drag.dragLight = v; });\n    this._rng(\"ctrl-drag-dark\", \"val-drag-dark\", v => { this.config.drag.dragDark = v; });\n    this._sel(\"ctrl-curve-type\", v => { this.config.drag.curveType = v; });\n    this._rng(\"ctrl-curve-strength\", \"val-curve-strength\", v => { this.config.drag.curveStrength = v; });\n\n    this._rng(\"ctrl-tension\", \"val-tension\", v => { this.config.tension.baseTension = v; });\n    this._rng(\"ctrl-tension-boost\", \"val-tension-boost\", v => { this.config.tension.brightBoost = v; });\n    this._rng(\"ctrl-bright-thresh\", \"val-bright-thresh\", v => { this.config.tension.brightThreshold = v; });\n    this._rng(\"ctrl-max-seg\", \"val-max-seg\", v => { this.config.tension.maxSegmentLength = v; });\n\n    this._rng(\"ctrl-weight\", \"val-weight\", v => { this.config.render.strokeWeight = v; });\n    this._rng(\"ctrl-opacity\", \"val-opacity\", v => { this.config.render.alpha = v; });\n    this._col(\"ctrl-bg-color\", \"val-bg-color\", v => { this.config.canvas.background = v; });\n    this._col(\"ctrl-stroke-color\", \"val-stroke-color\", v => { this.config.render.strokeHex = v; });\n\n    this._rng(\"ctrl-draw-progress\", \"val-draw-progress\", v => { this.config.animation.drawProgress = v / 100; }, v => `${Math.round(v)}%`);\n    this._rng(\"ctrl-anim-frames\", \"val-anim-frames\", v => { this.config.animation.totalFrames = v; });\n    this._rng(\"ctrl-hold-frames\", \"val-hold-frames\", v => { this.config.animation.holdFrames = v; });\n    this._sel(\"ctrl-anim-easing\", v => { this.config.animation.easing = v; });\n    this._rng(\"ctrl-fps\", \"val-fps\", v => { this.config.animation.fps = v; });\n\n    document.getElementById(\"btn-export-png\").addEventListener(\"click\", () => this.onExportPng?.());\n    document.getElementById(\"btn-export-svg\").addEventListener(\"click\", () => this.onExportSvg?.());\n    document.getElementById(\"btn-record-webm\").addEventListener(\"click\", () => this.onRecordWebM?.());\n    document.getElementById(\"btn-preview-anim\").addEventListener(\"click\", () => this.onPreviewAnim?.());\n  }\n\n  _rng(cid, vid, setter, fmt) {\n    const c = document.getElementById(cid), v = document.getElementById(vid);\n    if (!c) return;\n    c.addEventListener(\"input\", () => {\n      const val = parseFloat(c.value);\n      if (v) v.textContent = fmt ? fmt(val) : (val % 1 === 0 ? val : val.toFixed(2));\n      setter(val);\n    });\n  }\n  _sel(cid, setter) { const c = document.getElementById(cid); if (c) c.addEventListener(\"change\", () => setter(c.value)); }\n  _chk(cid, setter) { const c = document.getElementById(cid); if (c) c.addEventListener(\"change\", () => setter(c.checked)); }\n  _col(cid, vid, setter) {\n    const c = document.getElementById(cid), v = document.getElementById(vid);\n    if (c) c.addEventListener(\"input\", () => { if (v) v.textContent = c.value; setter(c.value); });\n  }\n\n  _flagStatic() { this.onStaticChange?.(); }\n  _flagAll() { this.onStaticChange?.(); this.onReset?.(); }\n\n  _syncVis() {\n    const m = this.config.engine.mode;\n    this.panels.flow.classList.toggle(\"hidden\", m !== \"flow\");\n    this.panels.static.classList.toggle(\"hidden\", m !== \"static\");\n    this.panels.serpOsc.classList.toggle(\"hidden\", m !== \"serpentine\");\n    this.panels.drag.classList.toggle(\"hidden\", m === \"static\");\n    this.panels.tension.classList.toggle(\"hidden\", m === \"static\");\n    this.grpOrientation.style.display = m === \"serpentine\" ? \"none\" : \"\";\n  }\n\n  _togglePause() {\n    this.paused = !this.paused;\n    this.btnPause.textContent = this.paused ? \"Resume\" : \"Pause\";\n    this.onPauseToggle?.(this.paused);\n  }\n\n  _handleFile(file) {\n    if (!file) return;\n    const reader = new FileReader();\n    reader.onload = e => {\n      const url = e.target.result;\n      this.previewImg.src = url;\n      this.previewImg.onload = () => {\n        this.fileName.textContent = file.name.length > 18 ? file.name.slice(0, 15) + \"...\" : file.name;\n        this.fileDims.textContent = `${this.previewImg.naturalWidth}\u00d7${this.previewImg.naturalHeight}`;\n        this.previewContainer.classList.add(\"active\");\n        this.setStatus(\"Processing...\");\n        this.onImageLoad?.(url);\n      };\n    };\n    reader.readAsDataURL(file);\n  }\n\n  setStatus(msg) { this.statusEl.textContent = msg; }\n  showRecordProgress(show) { this.recordTrack.style.display = show ? \"block\" : \"none\"; if (!show) this.recordFill.style.width = \"0%\"; }\n  setRecordProgress(pct) { this.recordFill.style.width = `${Math.round(pct * 100)}%`; }\n}\n\n// ============================================================\n// P5 HOOKS\n// ============================================================\nlet APP = null;\nlet UI = null;\n\nfunction setup() {\n  APP = new App(CONFIG);\n  APP.setup();\n  UI = new UIController(CONFIG);\n\n  UI.onImageLoad = url => APP.loadImage(url, (w, h) => UI.setStatus(`Loaded ${w}\u00d7${h}`));\n  UI.onReset = () => { APP.reset(); UI.setStatus(\"Reset\"); };\n  UI.onPauseToggle = p => { APP.setPaused(p); UI.setStatus(p ? \"Paused\" : \"Drawing...\"); };\n  UI.onScaleChange = s => { const d = APP.rescale(s); if (d) UI.setStatus(`Rescaled ${d.w}\u00d7${d.h}`); };\n  UI.onStaticChange = () => APP.flagStaticDirty();\n\n  UI.onExportPng = () => {\n    try {\n      UI.setStatus(\"Exporting PNG...\");\n      const wasPaused = APP.paused;\n      APP.paused = true;\n      APP.renderFrame();\n      setTimeout(() => {\n        try { ExportManager.exportPng(); UI.setStatus(\"PNG saved\"); }\n        catch (e) { UI.setStatus(\"PNG failed: \" + e.message); console.error(e); }\n        APP.paused = wasPaused;\n      }, 100);\n    } catch (e) { UI.setStatus(\"PNG failed: \" + e.message); console.error(e); }\n  };\n\n  UI.onExportSvg = () => {\n    try {\n      UI.setStatus(\"Exporting SVG...\");\n      const wasPaused = APP.paused;\n      APP.paused = true;\n      const lines = APP.getCurrentLines();\n      UI.setStatus(`Building SVG (${lines.length} lines)...`);\n      setTimeout(() => {\n        try {\n          const c = CONFIG;\n          ExportManager.exportSvg(lines, APP.canvasW, APP.canvasH, c.canvas.background, c.render.strokeHex, c.render.strokeWeight, c.render.alpha);\n          UI.setStatus(\"SVG saved\");\n        } catch (e) { UI.setStatus(\"SVG failed: \" + e.message); console.error(e); }\n        APP.paused = wasPaused;\n      }, 50);\n    } catch (e) { UI.setStatus(\"SVG failed: \" + e.message); console.error(e); }\n  };\n\n  UI.onPreviewAnim = () => {\n    if (!APP.imageReady) return;\n    const mode = CONFIG.engine.mode;\n    UI.setStatus(\"Previewing...\");\n\n    if (mode === \"flow\" || mode === \"serpentine\") {\n      APP.reset();\n      APP.setPaused(false);\n      const totalF = CONFIG.animation.totalFrames;\n      let frame = 0;\n      const iv = setInterval(() => {\n        frame++;\n        UI.setStatus(`Frame ${frame} / ${totalF}`);\n        if (frame >= totalF ||\n            (mode === \"flow\" && APP.flowEngine?.complete) ||\n            (mode === \"serpentine\" && APP.serpentineEngine?.complete)) {\n          APP.setPaused(true);\n          UI.setStatus(`Done \u2014 ${frame} frames`);\n          clearInterval(iv);\n        }\n      }, 1000 / CONFIG.animation.fps);\n    } else {\n      const totalF = CONFIG.animation.totalFrames;\n      const holdF = CONFIG.animation.holdFrames;\n      const fps = CONFIG.animation.fps;\n      const easing = CONFIG.animation.easing;\n      const allF = totalF + holdF;\n      let f = 0;\n      const slider = document.getElementById(\"ctrl-draw-progress\");\n      const valEl = document.getElementById(\"val-draw-progress\");\n      APP.paused = true;\n      const step = () => {\n        if (f >= allF) {\n          CONFIG.animation.drawProgress = 1.0;\n          slider.value = 100; valEl.textContent = \"100%\";\n          APP.flagStaticDirty();\n          UI.setStatus(\"Preview done\");\n          return;\n        }\n        const prog = f < totalF ? Easing.apply(f / Math.max(1, totalF - 1), easing) : 1.0;\n        CONFIG.animation.drawProgress = prog;\n        slider.value = Math.round(prog * 100);\n        valEl.textContent = `${Math.round(prog * 100)}%`;\n        APP.flagStaticDirty();\n        f++;\n        setTimeout(step, 1000 / fps);\n      };\n      step();\n    }\n  };\n\n  UI.onRecordWebM = () => {\n    if (!APP.imageReady) return;\n    const btn = document.getElementById(\"btn-record-webm\");\n    btn.classList.add(\"recording\"); btn.textContent = \"Recording...\"; btn.disabled = true;\n    UI.showRecordProgress(true);\n    UI.setStatus(\"Recording WebM...\");\n    ExportManager.recordWebM(APP,\n      pct => UI.setRecordProgress(pct),\n      blob => {\n        btn.classList.remove(\"recording\"); btn.textContent = \"Record WebM\"; btn.disabled = false;\n        UI.showRecordProgress(false);\n        UI.setStatus(blob ? \"WebM saved\" : \"Failed\");\n      }\n    );\n  };\n}\n\nfunction draw() { APP.draw(); }\n";
export const TOOL_FUNCTIONS = Object.fromEntries(TOOL_FUNCTION_NAMES.map((n) => [n, null]));
