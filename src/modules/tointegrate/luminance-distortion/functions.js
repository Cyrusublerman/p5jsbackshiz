// Extracted metadata module (safe text representation)
export const TOOL_SOURCE_PATH = "toIntegrate/luminance-distortion.html";
export const TOOL_EXTRACTION_MODE = "regex-only";
export const TOOL_FUNCTION_NAMES = [
  "resizeTo",
  "applyImage",
  "loadImg"
];
export const TOOL_REGEX_FUNCTION_NAMES = [
  "resizeTo",
  "applyImage",
  "loadImg"
];
export const TOOL_LLM_FUNCTION_NAMES = [];
export const TOOL_LLM_CAPABILITIES = [];
export const TOOL_LLM_NOTES = "";
export const TOOL_SOURCE_TEXT = "\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   UI: Accordion + Panel Toggle\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\ndocument.querySelectorAll('.sec-head').forEach(h => {\n  h.addEventListener('click', () => h.parentElement.classList.toggle('open'));\n});\ndocument.getElementById('togglePanel').addEventListener('click', () => {\n  document.getElementById('panel').classList.toggle('collapsed');\n});\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   ParamManager\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass ParamManager {\n  constructor() {\n    this.c = {};\n    const ids = [\n      'spacing','strokeW','resolution','damping',\n      'magMix','magCompress','magExpand',\n      'gradMix','gradStr','tangMix','tangStr',\n      'originMix','originStr','orbitR','orbitSpeed',\n      'angleMix','amplitude','xFactor','yFactor','dispAngle',\n      'sineMix','sineAmp','s1Freq','s1Mix','s2Freq','s2Mix','s3Freq','s3Mix','sinePhaseSpd',\n      'flowMix','flowStr','flowNS','flowCurl',\n      'steerGrad','steerTang','deadZone',\n      'timeSpeed','lumExp','bgAlpha'\n    ];\n    for (const id of ids) {\n      const el = document.getElementById(id);\n      if (!el) continue;\n      this.c[id] = parseFloat(el.value);\n      const vs = el.parentElement.querySelector('.val');\n      el.addEventListener('input', () => {\n        this.c[id] = parseFloat(el.value);\n        if (vs) {\n          const s = el.getAttribute('step');\n          vs.textContent = (s && s.includes('.'))\n            ? this.c[id].toFixed(s.split('.')[1].length) : this.c[id];\n        }\n      });\n    }\n  }\n  g(k) { return this.c[k]; }\n  s(id) { return document.getElementById(id).value; }\n  b(id) { return document.getElementById(id).checked; }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   VectorFieldMap \u2014 polar from Sobel\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass VectorFieldMap {\n  constructor() { this.w=0;this.h=0;this.ready=false;this.lum=null;this.mag=null;\n    this.cosA=null;this.sinA=null;this.tanCos=null;this.tanSin=null;this.maxMag=0; }\n\n  build(px, w, h, dz) {\n    this.w=w; this.h=h;\n    const n=w*h, L=new Float32Array(n);\n    for(let i=0;i<n;i++){const j=i*4; L[i]=(0.2126*px[j]+0.7152*px[j+1]+0.0722*px[j+2])/255;}\n    const gx=new Float32Array(n), gy=new Float32Array(n);\n    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){\n      const i=y*w+x;\n      gx[i]=-L[(y-1)*w+x-1]+L[(y-1)*w+x+1]-2*L[y*w+x-1]+2*L[y*w+x+1]-L[(y+1)*w+x-1]+L[(y+1)*w+x+1];\n      gy[i]=-L[(y-1)*w+x-1]-2*L[(y-1)*w+x]-L[(y-1)*w+x+1]+L[(y+1)*w+x-1]+2*L[(y+1)*w+x]+L[(y+1)*w+x+1];\n    }\n    this.lum=L;\n    this.mag=new Float32Array(n); this.cosA=new Float32Array(n); this.sinA=new Float32Array(n);\n    this.tanCos=new Float32Array(n); this.tanSin=new Float32Array(n);\n    let mx=0;\n    for(let i=0;i<n;i++){const m=Math.sqrt(gx[i]*gx[i]+gy[i]*gy[i]);if(m>mx)mx=m;}\n    this.maxMag=mx;\n    const dzF=Math.max(dz*2,0.001);\n    for(let i=0;i<n;i++){\n      const rm=Math.sqrt(gx[i]*gx[i]+gy[i]*gy[i]);\n      let t=0;if(rm>dz){t=Math.min((rm-dz)/dzF,1);t=t*t*(3-2*t);}\n      this.mag[i]=rm*t;\n      if(rm>0.0001){this.cosA[i]=gx[i]/rm;this.sinA[i]=gy[i]/rm;}\n      this.tanCos[i]=-this.sinA[i]; this.tanSin[i]=this.cosA[i];\n    }\n    this.ready=true;\n  }\n\n  sample(x,y) {\n    if(!this.ready) return{lum:.5,mag:0,cosA:0,sinA:0,tanCos:0,tanSin:1};\n    const ix=Math.max(0,Math.min(~~x,this.w-1)), iy=Math.max(0,Math.min(~~y,this.h-1)), i=iy*this.w+ix;\n    return{lum:this.lum[i],mag:this.mag[i],cosA:this.cosA[i],sinA:this.sinA[i],tanCos:this.tanCos[i],tanSin:this.tanSin[i]};\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   ForceSystem \u2014 pure generators returning {fx,fy}\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass ForceSystem {\n  constructor(vf,p){this.vf=vf;this.p=p;}\n  fixedAngle(lum,amp,xF,yF,cA,sA){return{fx:cA*lum*amp*xF,fy:sA*lum*amp*yF};}\n  originVec(bx,by,ox,oy,lum,str){const vx=bx-ox,vy=by-oy,d=Math.sqrt(vx*vx+vy*vy);if(d<.01)return{fx:0,fy:0};const s=lum*str*30;return{fx:(vx/d)*s,fy:(vy/d)*s};}\n  gradPush(vf,str){return{fx:vf.cosA*vf.mag*str,fy:vf.sinA*vf.mag*str};}\n  tangPush(vf,str){return{fx:vf.tanCos*vf.mag*str,fy:vf.tanSin*vf.mag*str};}\n  flow(bx,by,t,ns,curl,str,lum){\n    const a=this.p.noise(bx*ns,by*ns,t)*Math.PI*4;\n    let nx=Math.cos(a),ny=Math.sin(a);\n    if(curl>0){const rx=-ny,ry=nx;nx=nx*(1-curl)+rx*curl;ny=ny*(1-curl)+ry*curl;}\n    const m=Math.sqrt(nx*nx+ny*ny)+.0001;\n    return{fx:(nx/m)*str*lum,fy:(ny/m)*str*lum};\n  }\n  sine(idx,pNx,pNy,phase,amp,lumS,lum,pm){\n    const m1=pm.g('s1Mix'),m2=pm.g('s2Mix'),m3=pm.g('s3Mix');\n    let w=0;\n    if(m1>0)w+=Math.sin(idx*pm.g('s1Freq')*.01+phase)*m1;\n    if(m2>0)w+=Math.sin(idx*pm.g('s2Freq')*.01+phase*1.3)*m2;\n    if(m3>0)w+=Math.sin(idx*pm.g('s3Freq')*.01+phase*.7)*m3;\n    let d=w*amp;if(lumS)d*=lum;\n    return{fx:pNx*d,fy:pNy*d};\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   Steering \u2014 modulate composite direction\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass Steering {\n  static apply(fx,fy,vf,sg,st,emS,lS,maxM){\n    let outX=fx,outY=fy;\n    const mag=Math.sqrt(fx*fx+fy*fy);\n    if(mag<.001)return{fx:0,fy:0};\n\n    // Steer direction\n    const ts=sg+st;\n    if(ts>.001&&vf.mag>.001){\n      const na=Math.atan2(fy,fx);\n      let tC,tS;\n      if(sg>0&&st>0){const w=sg/ts;tC=vf.cosA*w+vf.tanCos*(1-w);tS=vf.sinA*w+vf.tanSin*(1-w);const m=Math.sqrt(tC*tC+tS*tS)+.0001;tC/=m;tS/=m;}\n      else if(sg>0){tC=vf.cosA;tS=vf.sinA;}else{tC=vf.tanCos;tS=vf.tanSin;}\n      const ta=Math.atan2(tS,tC),bl=Math.min(ts,1);\n      let df=ta-na;while(df>Math.PI)df-=Math.PI*2;while(df<-Math.PI)df+=Math.PI*2;\n      const fa=na+df*bl;\n      outX=Math.cos(fa)*mag;outY=Math.sin(fa)*mag;\n    }\n\n    // Edge magnitude scale\n    if(emS&&maxM>.001){\n      const s=vf.mag/maxM;\n      outX*=s; outY*=s;\n    }\n\n    // Lum scale\n    if(lS){outX*=vf.lum;outY*=vf.lum;}\n\n    return{fx:outX,fy:outY};\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   OriginAnimator\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass OriginAnimator {\n  constructor(cx,cy,p){this.cx=cx;this.cy=cy;this.x=cx;this.y=cy;this.p=p;}\n  recenter(cx,cy){this.cx=cx;this.cy=cy;}\n  update(t,r,spd,mode){\n    const ph=t*spd;\n    if(mode==='circular'){this.x=this.cx+Math.cos(ph)*r;this.y=this.cy+Math.sin(ph)*r;}\n    else if(mode==='lissajous'){this.x=this.cx+Math.cos(ph*3)*r;this.y=this.cy+Math.sin(ph*2)*r;}\n    else{this.x=this.cx+(this.p.noise(t*spd*.5,0)-.5)*r*2;this.y=this.cy+(this.p.noise(0,t*spd*.5)-.5)*r*2;}\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   ColorMapper\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass ColorMapper{constructor(){this.p={mono:l=>[l*255,l*255,l*255],thermal:l=>[l*255,l*80,(1-l)*200],ocean:l=>[(1-l)*30,l*120+80,l*200+55],neon:l=>[l*255,(1-l)*255,180+l*75]};}get(l,n){return(this.p[n]||this.p.mono)(l);}}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   LineGenerator\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass LineGenerator {\n  constructor(vf){this.vf=vf;}\n  generate(type,w,h,sp){\n    if(type==='radial'||type==='concentric')return this._rc(type,w,h,sp);\n    return this._build(type,w,h,this._pos(type,w,h,sp));\n  }\n  _pos(type,w,h,sp){\n    const o=[];\n    if(type==='horizontal'||type==='grid')for(let y=0;y<h;y+=sp)o.push(y);\n    else if(type==='vertical')for(let x=0;x<w;x+=sp)o.push(x);\n    else if(type==='diagonal')for(let d=-h;d<w+h;d+=sp)o.push(d);\n    return o;\n  }\n  _build(type,w,h,pos){\n    const out=[],n=pos.length;\n    for(let i=0;i<n;i++){\n      const p=pos[i],pts=[];\n      if(type==='horizontal'||type==='grid')for(let x=0;x<w;x++)pts.push({x,y:p});\n      else if(type==='vertical')for(let y=0;y<h;y++)pts.push({x:p,y});\n      else if(type==='diagonal')for(let t=0;t<w+h;t++){const x=p+t*.707,y=t*.707;if(x>=0&&x<w&&y>=0&&y<h)pts.push({x,y});}\n      if(pts.length>2)out.push({pts,idx:i});\n    }\n    if(type==='grid'){const sp=n>1?pos[1]-pos[0]:10;for(let x=0;x<w;x+=sp){const pts=[];for(let y=0;y<h;y++)pts.push({x,y});out.push({pts,idx:-1});}}\n    return out;\n  }\n  _rc(type,w,h,sp){\n    const out=[],PI2=Math.PI*2,cx=w/2,cy=h/2,mr=Math.sqrt(cx*cx+cy*cy);\n    if(type==='radial'){const as=sp*.02;for(let a=0;a<PI2;a+=as){const pts=[];for(let r=0;r<mr;r+=2)pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(a)*r});out.push({pts,idx:out.length});}}\n    else{for(let r=sp;r<mr;r+=sp){const pts=[],sg=Math.max(60,~~(r*.5));for(let j=0;j<=sg;j++){const a=(j/sg)*PI2;pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(a)*r});}out.push({pts,idx:out.length});}}\n    return out;\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   DisplacementMatrix \u2014 persistent across frames\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass DisplacementMatrix {\n  constructor(){this.data=[];this.nLines=0;this.nPts=[];}\n\n  resize(lines, res) {\n    const nl = lines.length;\n    const newData = [];\n    const newNPts = [];\n    for (let l = 0; l < nl; l++) {\n      const np = Math.ceil(lines[l].pts.length / res);\n      newNPts.push(np);\n      const arr = new Float32Array(np * 2); // [fx0,fy0, fx1,fy1, ...]\n      // Copy old data if dimensions match\n      if (l < this.nLines && np === this.nPts[l] && this.data[l]) {\n        arr.set(this.data[l].subarray(0, Math.min(this.data[l].length, np*2)));\n      }\n      newData.push(arr);\n    }\n    this.data = newData;\n    this.nLines = nl;\n    this.nPts = newNPts;\n  }\n\n  damp(factor) {\n    for (let l = 0; l < this.nLines; l++) {\n      const d = this.data[l];\n      for (let i = 0; i < d.length; i++) d[i] *= factor;\n    }\n  }\n\n  getFx(l,p) { return this.data[l][p*2]; }\n  getFy(l,p) { return this.data[l][p*2+1]; }\n  addFx(l,p,v) { this.data[l][p*2] += v; }\n  addFy(l,p,v) { this.data[l][p*2+1] += v; }\n  setFx(l,p,v) { this.data[l][p*2] = v; }\n  setFy(l,p,v) { this.data[l][p*2+1] = v; }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   Renderer \u2014 pipeline: damp \u2192 generate \u2192 constrain \u2192 modulate \u2192 draw\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass Renderer {\n  constructor(vf,lineGen,forces,colors,p5){\n    this.vf=vf;this.lineGen=lineGen;this.fs=forces;this.cm=colors;this.p=p5;\n    this.dm=new DisplacementMatrix();\n  }\n\n  render(pm,origin,t){\n    const p=this.p, w=p.width, h=p.height;\n    const res=pm.g('resolution'), lExp=pm.g('lumExp');\n    const type=pm.s('patternType');\n    const lines=this.lineGen.generate(type,w,h,pm.g('spacing'));\n\n    // Resize matrix if topology changed\n    this.dm.resize(lines, res);\n    const dm=this.dm;\n\n    // \u2550\u2550\u2550 STAGE 1: DAMP \u2550\u2550\u2550\n    dm.damp(1 - pm.g('damping'));\n\n    // Pre-calc force params\n    const cA=Math.cos(pm.g('dispAngle')*Math.PI/180), sA=Math.sin(pm.g('dispAngle')*Math.PI/180);\n    const sPhase=t*60*pm.g('sinePhaseSpd');\n    const fs=this.fs;\n\n    // Perpendicular axis for line type\n    let pAx,pAy;\n    if(type==='horizontal'||type==='grid'){pAx=0;pAy=1;}\n    else if(type==='vertical'){pAx=1;pAy=0;}\n    else if(type==='diagonal'){pAx=-0.707;pAy=0.707;}\n    else{pAx=0;pAy=1;}\n\n    // \u2550\u2550\u2550 STAGE 2: GENERATORS \u2550\u2550\u2550\n    for(let l=0;l<lines.length;l++){\n      const pts=lines[l].pts;\n      const nPts=dm.nPts[l];\n      for(let pi=0;pi<nPts;pi++){\n        const i=pi*res;\n        if(i>=pts.length) break;\n        const bx=pts[i].x, by=pts[i].y;\n        const vf=this.vf.sample(bx,by);\n        const lum=Math.pow(vf.lum,lExp);\n\n        // Per-point perpendicular\n        const iPr=Math.max(0,i-res), iNx=Math.min(pts.length-1,i+res);\n        const tx=pts[iNx].x-pts[iPr].x, ty=pts[iNx].y-pts[iPr].y;\n        const tm=Math.sqrt(tx*tx+ty*ty)+.001;\n        const pNx=-ty/tm, pNy=tx/tm;\n\n        let fx=0, fy=0, v;\n\n        // Fixed angle\n        const aMix=pm.g('angleMix');\n        if(aMix>0 && pm.g('amplitude')>0){\n          v=fs.fixedAngle(lum,pm.g('amplitude'),pm.g('xFactor'),pm.g('yFactor'),cA,sA);\n          fx+=v.fx*aMix; fy+=v.fy*aMix;\n        }\n\n        // Origin radial\n        const oMix=pm.g('originMix');\n        if(oMix>0 && pm.g('originStr')>0){\n          v=fs.originVec(bx,by,origin.x,origin.y,lum,pm.g('originStr'));\n          fx+=v.fx*oMix; fy+=v.fy*oMix;\n        }\n\n        // Gradient push\n        const gMix=pm.g('gradMix');\n        if(gMix>0 && pm.g('gradStr')>0){\n          v=fs.gradPush(vf,pm.g('gradStr'));\n          fx+=v.fx*gMix; fy+=v.fy*gMix;\n        }\n\n        // Tangent push\n        const tMix=pm.g('tangMix');\n        if(tMix>0 && pm.g('tangStr')>0){\n          v=fs.tangPush(vf,pm.g('tangStr'));\n          fx+=v.fx*tMix; fy+=v.fy*tMix;\n        }\n\n        // Flow field\n        const fMix=pm.g('flowMix');\n        if(fMix>0 && pm.g('flowStr')>0){\n          v=fs.flow(bx,by,t,pm.g('flowNS'),pm.g('flowCurl'),pm.g('flowStr'),lum);\n          fx+=v.fx*fMix; fy+=v.fy*fMix;\n        }\n\n        // Sine waves\n        const sMix=pm.g('sineMix');\n        if(sMix>0 && pm.g('sineAmp')>0){\n          v=fs.sine(i,pNx,pNy,sPhase,pm.g('sineAmp'),pm.b('sineLumScale'),lum,pm);\n          fx+=v.fx*sMix; fy+=v.fy*sMix;\n        }\n\n        // Add to persistent matrix (force \u00d7 dt \u2248 force since we run per frame)\n        dm.addFx(l,pi,fx);\n        dm.addFy(l,pi,fy);\n      }\n    }\n\n    // \u2550\u2550\u2550 STAGE 3: CONSTRAINTS \u2014 Magnetism \u2550\u2550\u2550\n    // Direct position constraint: computes target perpendicular positions\n    // per column and SETS the perpendicular displacement component.\n    // Immune to damping because it writes absolute positions, not incremental forces.\n    const magMix=pm.g('magMix');\n    const canMag=magMix>0 && (type==='horizontal'||type==='vertical'||type==='diagonal');\n\n    if(canMag){\n      const compress=pm.g('magCompress');\n      const expand=pm.g('magExpand');\n      const parAx=pAy, parAy=-pAx; // parallel axis (90\u00b0 rotation of perp)\n\n      // Filter ordered lines (exclude grid verticals which have idx=-1)\n      const ordered=[];\n      for(let l=0;l<lines.length;l++){if(lines[l].idx>=0)ordered.push(l);}\n      const nOrd=ordered.length;\n\n      if(nOrd>1){\n        const maxSamp=Math.max(...ordered.map(l=>dm.nPts[l]));\n\n        for(let pi=0;pi<maxSamp;pi++){\n          // Gather base perp positions and current displacement components\n          const baseP=[], curPar=[], curPerp=[];\n          for(let oi=0;oi<nOrd;oi++){\n            const li=ordered[oi];\n            const si=Math.min(pi,dm.nPts[li]-1);\n            const idx=si*res;\n            if(idx>=lines[li].pts.length){\n              baseP.push(oi>0?baseP[oi-1]+pm.g('spacing'):0);\n              curPerp.push(0);curPar.push(0);continue;\n            }\n            const bx=lines[li].pts[idx].x, by=lines[li].pts[idx].y;\n            baseP.push(bx*pAx+by*pAy);\n            const dfx=dm.getFx(li,si), dfy=dm.getFy(li,si);\n            curPerp.push(dfx*pAx+dfy*pAy);\n            curPar.push(dfx*parAx+dfy*parAy);\n          }\n\n          // Compute target gaps from luminance at BASE midpoints (stable)\n          const targetGaps=[];\n          for(let oi=0;oi<nOrd-1;oi++){\n            const li0=ordered[oi], li1=ordered[oi+1];\n            const si0=Math.min(pi,dm.nPts[li0]-1), si1=Math.min(pi,dm.nPts[li1]-1);\n            const idx0=si0*res, idx1=si1*res;\n            if(idx0>=lines[li0].pts.length||idx1>=lines[li1].pts.length){\n              targetGaps.push(pm.g('spacing'));continue;\n            }\n            const b0=lines[li0].pts[idx0], b1=lines[li1].pts[idx1];\n            const mx=(b0.x+b1.x)/2, my=(b0.y+b1.y)/2;\n            const midLum=Math.pow(this.vf.sample(mx,my).lum,lExp);\n\n            const baseGap=baseP[oi+1]-baseP[oi];\n            // white(1) \u2192 gap*(1-compress), black(0) \u2192 gap*expand\n            const factor=midLum*(1-compress)+(1-midLum)*expand;\n            targetGaps.push(Math.max(baseGap*factor, 0.3));\n          }\n\n          // Rebuild positions: center-anchored from cumulative target gaps\n          const totalTarget=targetGaps.reduce((a,b)=>a+b,0);\n          const baseCenter=(baseP[0]+baseP[nOrd-1])/2;\n          const newStart=baseCenter-totalTarget/2;\n          const newPerp=[newStart];\n          for(let oi=0;oi<nOrd-1;oi++) newPerp.push(newPerp[oi]+targetGaps[oi]);\n\n          // Blend and write back\n          for(let oi=0;oi<nOrd;oi++){\n            const li=ordered[oi];\n            const si=Math.min(pi,dm.nPts[li]-1);\n            const idx=si*res;\n            if(idx>=lines[li].pts.length)continue;\n\n            const oldPerp=baseP[oi]+curPerp[oi];\n            const tgtPerp=newPerp[oi];\n            const finalPerp=oldPerp+(tgtPerp-oldPerp)*magMix;\n            const newDispPerp=finalPerp-baseP[oi];\n\n            // Reconstruct: preserve parallel component, replace perpendicular\n            dm.setFx(li,si, curPar[oi]*parAx + newDispPerp*pAx);\n            dm.setFy(li,si, curPar[oi]*parAy + newDispPerp*pAy);\n          }\n        }\n      }\n    }\n\n    // \u2550\u2550\u2550 STAGE 4: MODULATORS \u2014 steer + scale composite \u2550\u2550\u2550\n    const sg=pm.g('steerGrad'), st=pm.g('steerTang');\n    const emS=pm.b('edgeMagScale'), lS=pm.b('lumScale');\n    const doMod=sg>.001||st>.001||emS||lS;\n\n    if(doMod){\n      for(let l=0;l<lines.length;l++){\n        const pts=lines[l].pts;\n        for(let pi=0;pi<dm.nPts[l];pi++){\n          const i=pi*res;\n          if(i>=pts.length)break;\n          const vf=this.vf.sample(pts[i].x,pts[i].y);\n          let fx=dm.getFx(l,pi), fy=dm.getFy(l,pi);\n          const r=Steering.apply(fx,fy,vf,sg,st,emS,lS,this.vf.maxMag);\n          // Lerp: each modulator's mix is already inside Steering.apply\n          // but we need lerp for steer\n          if(sg>.001||st>.001){\n            const bl=Math.min(sg+st,1);\n            dm.setFx(l,pi, fx+(r.fx-fx)*bl);\n            dm.setFy(l,pi, fy+(r.fy-fy)*bl);\n          } else {\n            dm.setFx(l,pi, r.fx);\n            dm.setFy(l,pi, r.fy);\n          }\n        }\n      }\n    }\n\n    // \u2550\u2550\u2550 STAGE 5: RENDER \u2550\u2550\u2550\n    p.strokeWeight(pm.g('strokeW'));\n    p.noFill();\n    const doColor=pm.b('colorMode'), pal=pm.s('palette');\n\n    for(let l=0;l<lines.length;l++){\n      const pts=lines[l].pts;\n      p.beginShape();\n      for(let pi=0;pi<dm.nPts[l];pi++){\n        const i=pi*res;\n        if(i>=pts.length)break;\n        const bx=pts[i].x, by=pts[i].y;\n        const lum=Math.pow(this.vf.sample(bx,by).lum,lExp);\n\n        if(doColor){const c=this.cm.get(lum,pal);p.stroke(c[0],c[1],c[2],200);}\n        else p.stroke(255,50+lum*200);\n\n        p.curveVertex(bx+dm.getFx(l,pi), by+dm.getFy(l,pi));\n      }\n      p.endShape();\n    }\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   DebugOverlay\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nclass DebugOverlay {\n  constructor(vf,fs,p){this.vf=vf;this.fs=fs;this.p=p;}\n  drawVF(w,h){\n    const p=this.p,step=14,mx=this.vf.maxMag;if(mx<.001)return;\n    p.strokeWeight(.5);\n    for(let x=0;x<w;x+=step)for(let y=0;y<h;y+=step){\n      const s=this.vf.sample(x,y),nm=s.mag/mx,len=nm*step*.8;\n      if(len<.3)continue;\n      const hu=(Math.atan2(s.sinA,s.cosA)/Math.PI+1)*.5;\n      p.stroke((Math.cos(hu*6.28)*.5+.5)*255,(Math.cos(hu*6.28+2.09)*.5+.5)*255,(Math.cos(hu*6.28+4.19)*.5+.5)*255,60+nm*100);\n      p.line(x,y,x+s.cosA*len,y+s.sinA*len);\n    }\n  }\n  drawFlow(w,h,t,ns,curl){\n    const p=this.p,step=18;p.stroke(0,255,120,40);p.strokeWeight(.5);\n    for(let x=0;x<w;x+=step)for(let y=0;y<h;y+=step){\n      const f=this.fs.flow(x,y,t,ns,curl,1,1);\n      p.line(x,y,x+f.fx*step*.6,y+f.fy*step*.6);\n    }\n  }\n  drawOrigin(ox,oy){\n    const p=this.p;p.noFill();p.stroke(255,80,80,160);p.strokeWeight(1);\n    p.ellipse(ox,oy,12,12);p.line(ox-7,oy,ox+7,oy);p.line(ox,oy-7,ox,oy+7);\n  }\n}\n\n/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   Bootstrap\n   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */\nlet app=null, rawImg=null, rawW=0, rawH=0;\n\nnew p5(p => {\n  let pm,vf,lg,fs,cm,rend,oa,dov,srcImg=null,cw,ch,t=0;\n\n  function resizeTo(tw,th){cw=tw;ch=th;p.resizeCanvas(cw,ch);oa.recenter(cw/2,ch/2);}\n\n  function applyImage(img,scale){\n    const tw=Math.round(rawW*scale),th=Math.round(rawH*scale);\n    resizeTo(tw,th);\n    const oc=document.createElement('canvas');oc.width=tw;oc.height=th;\n    const ctx=oc.getContext('2d');ctx.drawImage(img,0,0,tw,th);\n    const id=ctx.getImageData(0,0,tw,th);\n    const p5i=p.createImage(tw,th);p5i.loadPixels();\n    for(let i=0;i<id.data.length;i++)p5i.pixels[i]=id.data[i];\n    p5i.updatePixels();srcImg=p5i;\n    vf.build(id.data,tw,th,pm.g('deadZone'));\n    // Reset displacement matrix on new image\n    rend.dm.nLines=0;\n    document.getElementById('img-info').textContent=rawW+'\\u00d7'+rawH+' \\u2192 '+tw+'\\u00d7'+th+' ('+scale+'x)';\n  }\n\n  p.setup=()=>{\n    const wr=document.getElementById('canvas-wrap');\n    cw=wr.clientWidth;ch=wr.clientHeight;\n    p.createCanvas(cw,ch).parent('canvas-wrap');\n    pm=new ParamManager();vf=new VectorFieldMap();lg=new LineGenerator(vf);\n    fs=new ForceSystem(vf,p);cm=new ColorMapper();\n    rend=new Renderer(vf,lg,fs,cm,p);\n    oa=new OriginAnimator(cw/2,ch/2,p);dov=new DebugOverlay(vf,fs,p);\n\n    const px=new Uint8ClampedArray(cw*ch*4);\n    for(let y=0;y<ch;y++)for(let x=0;x<cw;x++){\n      const v=p.noise(x*.008,y*.008)*255,i=(y*cw+x)*4;\n      px[i]=px[i+1]=px[i+2]=v;px[i+3]=255;\n    }\n    vf.build(px,cw,ch,pm.g('deadZone'));\n    app={p,vf,applyImage,pm};\n  };\n\n  p.draw=()=>{\n    p.background(10,pm.g('bgAlpha'));\n    t+=pm.g('timeSpeed');\n    if(pm.b('showImage')&&srcImg){p.tint(255,50);p.image(srcImg,0,0,cw,ch);p.noTint();}\n    if(pm.b('animateOrigin'))oa.update(t*60,pm.g('orbitR'),pm.g('orbitSpeed'),pm.s('originMode'));\n    else{oa.x=cw/2;oa.y=ch/2;}\n    rend.render(pm,oa,t);\n    if(pm.b('showVF'))dov.drawVF(cw,ch);\n    if(pm.b('showFlow'))dov.drawFlow(cw,ch,t,pm.g('flowNS'),pm.g('flowCurl'));\n    if(pm.b('animateOrigin'))dov.drawOrigin(oa.x,oa.y);\n  };\n});\n\n/* \u2550\u2550\u2550 Image Loading \u2550\u2550\u2550 */\nfunction loadImg(file){\n  const r=new FileReader();\n  r.onload=e=>{if(!app)return;const img=new Image();img.onload=()=>{rawImg=img;rawW=img.naturalWidth;rawH=img.naturalHeight;app.applyImage(rawImg,parseFloat(document.getElementById('imgScale').value));};img.src=e.target.result;};\n  r.readAsDataURL(file);\n}\ndocument.getElementById('imgScale').addEventListener('change',()=>{if(rawImg&&app)app.applyImage(rawImg,parseFloat(document.getElementById('imgScale').value));});\ndocument.getElementById('deadZone').addEventListener('change',()=>{if(rawImg&&app)app.applyImage(rawImg,parseFloat(document.getElementById('imgScale').value));});\n\nconst dz=document.getElementById('drop-zone'),fi=document.getElementById('file-input');\ndz.addEventListener('dragover',e=>{e.preventDefault();dz.classList.add('over');});\ndz.addEventListener('dragleave',()=>dz.classList.remove('over'));\ndz.addEventListener('drop',e=>{e.preventDefault();dz.classList.remove('over');if(e.dataTransfer.files[0])loadImg(e.dataTransfer.files[0]);});\nfi.addEventListener('change',e=>{if(e.target.files[0])loadImg(e.target.files[0]);});\ndocument.getElementById('saveBtn').addEventListener('click',()=>{if(app)app.p.saveCanvas('luminance-flow','png');});\n";
export const TOOL_FUNCTIONS = Object.fromEntries(TOOL_FUNCTION_NAMES.map((n) => [n, null]));
