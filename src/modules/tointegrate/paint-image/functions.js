// Extracted metadata module (safe text representation)
export const TOOL_SOURCE_PATH = "toIntegrate/paint-image/paint-image/src/script.js";
export const TOOL_EXTRACTION_MODE = "regex-only";
export const TOOL_FUNCTION_NAMES = [
  "setup",
  "draw",
  "handleFileDrop"
];
export const TOOL_REGEX_FUNCTION_NAMES = [
  "setup",
  "draw",
  "handleFileDrop"
];
export const TOOL_LLM_FUNCTION_NAMES = [];
export const TOOL_LLM_CAPABILITIES = [];
export const TOOL_LLM_NOTES = "";
export const TOOL_SOURCE_TEXT = "/**\n * GENERATIVE PAINTER - BRUTALIST EDITION\n */\n\nconst config = {\n  brushMinSize: 10,\n  brushMaxSize: 50,\n  minOpacity: 10,\n  maxOpacity: 50,\n  iterationsPerFrame: 20,\n  maxAverageLayers: 15,\n  maxPixelLayers: 20,\n  palette: [] \n};\n\nlet painter;\nlet ui;\nlet sourceImg = null;\nlet weightMapImg = null;\n\nfunction setup() {\n  let canvas = createCanvas(600, 600);\n  canvas.parent('canvas-container');\n  canvas.drop(handleFileDrop);\n  \n  pixelDensity(1);\n  background(0); // Black canvas to match theme\n  \n  painter = new Painter();\n  ui = new UIManager();\n  \n  ui.updatePaletteFromInput();\n}\n\nfunction draw() {\n  if (painter && painter.isActive && sourceImg) {\n    painter.update();\n  }\n}\n\nfunction handleFileDrop(file) {\n  if (file.type === 'image') {\n    ui.loadSourceImage(file.data);\n  }\n}\n\n// --- PAINTER ENGINE ---\nclass Painter {\n  constructor() {\n    this.isActive = false;\n    this.layerTracker = null;\n    this.brush = new GradientBrush();\n    this.frameCount = 0;\n  }\n\n  init(img) {\n    resizeCanvas(img.width, img.height);\n    sourceImg = img;\n    sourceImg.loadPixels();\n    \n    if(weightMapImg) {\n      weightMapImg.resize(img.width, img.height);\n      weightMapImg.loadPixels();\n    }\n    \n    this.layerTracker = new LayerTracker(width, height);\n    \n    // Start with black background for that screen feel\n    background(0);\n    this.isActive = true;\n    this.frameCount = 0;\n    \n    ui.updateStatus(\"PROCESSING...\");\n    select('.placeholder').style('display', 'none');\n  }\n\n  update() {\n    let avgLayers = this.layerTracker.getAverageLayers();\n    ui.updateStats(avgLayers);\n\n    if (avgLayers >= config.maxAverageLayers) {\n      this.isActive = false;\n      ui.updateStatus(\"COMPLETE\");\n      return;\n    }\n\n    for (let i = 0; i < config.iterationsPerFrame; i++) {\n      this.paintStep();\n    }\n  }\n\n  paintStep() {\n    let x = floor(random(width));\n    let y = floor(random(height));\n\n    if (weightMapImg) {\n      let idx = (x + y * weightMapImg.width) * 4;\n      if (random(255) > weightMapImg.pixels[idx]) return; \n    }\n\n    if (this.layerTracker.getPixelLayers(x, y) > config.maxPixelLayers) return;\n\n    let targetColor = this.getSourcePixel(x, y);\n    let currentColor = get(x, y); \n\n    let bestColor = this.findBestColor(currentColor, targetColor);\n\n    if (bestColor) {\n      let op = random(config.minOpacity, config.maxOpacity);\n      let sz = random(config.brushMinSize, config.brushMaxSize);\n      \n      this.brush.draw(x, y, sz, bestColor, op);\n      this.layerTracker.addLayer(x, y, sz);\n    }\n  }\n\n  getSourcePixel(x, y) {\n    let loc = (x + y * sourceImg.width) * 4;\n    return [sourceImg.pixels[loc], sourceImg.pixels[loc + 1], sourceImg.pixels[loc + 2]];\n  }\n\n  findBestColor(current, target) {\n    let bestHex = null;\n    let minDiff = Infinity;\n\n    for (let hex of config.palette) {\n      let pCol = color(hex);\n      let alphaNorm = ((config.minOpacity + config.maxOpacity) / 2) / 255;\n      \n      let simR = lerp(current[0], red(pCol), alphaNorm);\n      let simG = lerp(current[1], green(pCol), alphaNorm);\n      let simB = lerp(current[2], blue(pCol), alphaNorm);\n\n      let d = (simR - target[0])**2 + (simG - target[1])**2 + (simB - target[2])**2;\n\n      if (d < minDiff) {\n        minDiff = d;\n        bestHex = hex;\n      }\n    }\n    return bestHex;\n  }\n}\n\n// --- BRUSH ---\nclass GradientBrush {\n  draw(x, y, size, hexColor, opacity) {\n    let ctx = drawingContext;\n    let radius = size / 2;\n    let grad = ctx.createRadialGradient(x, y, 0, x, y, radius);\n    let c = color(hexColor);\n    \n    grad.addColorStop(0, `rgba(${red(c)}, ${green(c)}, ${blue(c)}, ${opacity/255})`);\n    grad.addColorStop(1, `rgba(${red(c)}, ${green(c)}, ${blue(c)}, 0)`);\n    \n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, TWO_PI);\n    ctx.fill();\n  }\n}\n\n// --- TRACKER ---\nclass LayerTracker {\n  constructor(w, h) {\n    this.width = w;\n    this.length = w * h;\n    this.grid = new Float32Array(this.length).fill(0); \n    this.totalPaintStrokes = 0;\n  }\n\n  addLayer(x, y, size) {\n    let r = Math.floor(size / 4); \n    let startX = constrain(x - r, 0, this.width);\n    let endX = constrain(x + r, 0, this.width);\n    let startY = constrain(y - r, 0, height);\n    let endY = constrain(y + r, 0, height);\n\n    for (let i = startX; i < endX; i++) {\n      for (let j = startY; j < endY; j++) {\n        this.grid[i + j * this.width] += 1;\n      }\n    }\n    this.totalPaintStrokes++;\n  }\n\n  getPixelLayers(x, y) {\n    if (x < 0 || x >= this.width || y < 0 || y >= height) return 999;\n    return this.grid[x + y * this.width];\n  }\n\n  getAverageLayers() {\n    let avgBrushR = (config.brushMinSize + config.brushMaxSize) / 4;\n    let avgBrushArea = PI * (avgBrushR * avgBrushR);\n    return (this.totalPaintStrokes * avgBrushArea) / (this.length);\n  }\n}\n\n// --- UI MANAGER ---\nclass UIManager {\n  constructor() {\n    this.bindEvents();\n  }\n\n  bindEvents() {\n    select('#img-upload').elt.onchange = (e) => this.handleUpload(e, 'source');\n    select('#map-upload').elt.onchange = (e) => this.handleUpload(e, 'map');\n    \n    select('#btn-update-palette').mousePressed(() => this.updatePaletteFromInput());\n    \n    this.bindSlider('min-size', 'val-min-size', (v) => config.brushMinSize = int(v));\n    this.bindSlider('max-size', 'val-max-size', (v) => config.brushMaxSize = int(v));\n    this.bindSlider('speed', 'val-speed', (v) => config.iterationsPerFrame = int(v));\n    this.bindSlider('layer-limit', 'val-limit', (v) => config.maxAverageLayers = int(v));\n    \n    select('#min-opacity').input(() => {\n       config.minOpacity = int(select('#min-opacity').value());\n       this.updateOpacityLabel();\n    });\n    select('#max-opacity').input(() => {\n       config.maxOpacity = int(select('#max-opacity').value());\n       this.updateOpacityLabel();\n    });\n\n    select('#btn-reset').mousePressed(() => {\n       if(sourceImg) painter.init(sourceImg);\n    });\n    \n    select('#btn-pause').mousePressed(() => {\n       if(painter) {\n         painter.isActive = !painter.isActive;\n         this.updateStatus(painter.isActive ? \"PROCESSING...\" : \"PAUSED\");\n       }\n    });\n\n    select('#btn-save').mousePressed(() => {\n       saveCanvas('GENERATED_ART', 'jpg');\n    });\n  }\n\n  bindSlider(id, labelId, callback) {\n    let el = select('#' + id);\n    el.input(() => {\n      let val = el.value();\n      select('#' + labelId).html(val);\n      callback(val);\n    });\n  }\n\n  updateOpacityLabel() {\n    select('#val-opacity').html(`${config.minOpacity}-${config.maxOpacity}`);\n  }\n\n  handleUpload(e, type) {\n    let file = e.target.files[0];\n    if (file) {\n      let reader = new FileReader();\n      reader.onload = (event) => {\n        let url = event.target.result;\n        loadImage(url, (img) => {\n          if (type === 'source') this.loadSourceImage(img);\n          if (type === 'map') {\n            weightMapImg = img;\n            console.log(\"MAP LOADED\");\n          }\n        });\n      };\n      reader.readAsDataURL(file);\n    }\n  }\n\n  loadSourceImage(img) {\n    if(painter) painter.init(img);\n    select('#img-upload').elt.value = '';\n  }\n  \n  updatePaletteFromInput() {\n    let txt = select('#palette-input').value();\n    let colors = txt.split(',').map(s => s.trim());\n    config.palette = colors;\n  }\n  \n  updateStats(avg) {\n    select('#stat-avg-layers').html(nf(avg, 1, 2));\n  }\n  \n  updateStatus(msg) {\n    select('#status-text').html(msg);\n  }\n}\n";
export const TOOL_FUNCTIONS = Object.fromEntries(TOOL_FUNCTION_NAMES.map((n) => [n, null]));
