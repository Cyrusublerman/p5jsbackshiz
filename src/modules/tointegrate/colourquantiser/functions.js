// Extracted metadata module (safe text representation)
export const TOOL_SOURCE_PATH = "toIntegrate/colourquantiser/colourquantiser/src/script.js";
export const TOOL_EXTRACTION_MODE = "regex-only";
export const TOOL_FUNCTION_NAMES = [
  "main",
  "logWithTimestamp",
  "deltaE76",
  "clamp",
  "vecDot",
  "vecSub",
  "vecAdd",
  "vecScale",
  "vecMagSq",
  "projectOntoSegment",
  "pickNearestInLargePalette",
  "findOppositeColor",
  "findDitherStrategy_NearestOpposite",
  "ditherNearestOppositeChecked",
  "doNoDitherLargePalette",
  "applyImageAdjustments",
  "showStatus",
  "formatHex",
  "renderPaletteSwatches",
  "getUserPalette",
  "parsePaletteFile",
  "updatePreview",
  "loadImage",
  "loadBlueNoise",
  "initializeApp",
  "processTexture"
];
export const TOOL_REGEX_FUNCTION_NAMES = [
  "main",
  "logWithTimestamp",
  "deltaE76",
  "clamp",
  "vecDot",
  "vecSub",
  "vecAdd",
  "vecScale",
  "vecMagSq",
  "projectOntoSegment",
  "pickNearestInLargePalette",
  "findOppositeColor",
  "findDitherStrategy_NearestOpposite",
  "ditherNearestOppositeChecked",
  "doNoDitherLargePalette",
  "applyImageAdjustments",
  "showStatus",
  "formatHex",
  "renderPaletteSwatches",
  "getUserPalette",
  "parsePaletteFile",
  "updatePreview",
  "loadImage",
  "loadBlueNoise",
  "initializeApp",
  "processTexture"
];
export const TOOL_LLM_FUNCTION_NAMES = [];
export const TOOL_LLM_CAPABILITIES = [];
export const TOOL_LLM_NOTES = "";
export const TOOL_SOURCE_TEXT = "/*\n * Image Quantization & Dithering Tool - script.js\n * COMPLETE CODE - Includes all features and logging.\n * Generated: Friday, April 11, 2025 at 1:17:36 PM AEST\n */\n\n// Wrap everything in an IIFE (Immediately Invoked Function Expression)\n// to avoid polluting the global scope\n(function main() {\n\n    /*****************************************************\n     * 1) ColorSpaceConverter: sRGB <-> LAB\n     *****************************************************/\n    class ColorSpaceConverter {\n        constructor() {\n            this.cache = new Map();\n            // D65 reference white point\n            this.WHITE_REFERENCE = { X: 0.95047, Y: 1.0, Z: 1.08883 };\n            this.epsilon = 0.008856; // CIE standard thresholds\n            this.kappa = 903.3;\n        }\n\n        // --- Public Methods ---\n\n        hexToRgb(hex) {\n            const key = `hex-${hex}`;\n            if (this.cache.has(key)) return this.cache.get(key);\n\n            const c = hex.startsWith(\"#\") ? hex.slice(1) : hex;\n            let fullHex = c;\n            if (c.length === 3) {\n                fullHex = c[0] + c[0] + c[1] + c[1] + c[2] + c[2];\n            }\n            // More robust check for valid hex characters\n            if (fullHex.length !== 6 || !/^[0-9a-fA-F]{6}$/.test(fullHex)) {\n                console.warn(`Invalid hex: ${hex}. Defaulting to black.`);\n                fullHex = '000000';\n            }\n\n            const rgb = {\n                r: parseInt(fullHex.slice(0, 2), 16),\n                g: parseInt(fullHex.slice(2, 4), 16),\n                b: parseInt(fullHex.slice(4, 6), 16)\n            };\n            this.cache.set(key, rgb);\n            return rgb;\n        }\n\n        rgbToLab(r, g, b) {\n            const key = `rgb-${r}-${g}-${b}`;\n            if (this.cache.has(key)) return this.cache.get(key);\n\n            // Ensure inputs are valid numbers\n            r = Number.isFinite(r) ? r : 0;\n            g = Number.isFinite(g) ? g : 0;\n            b = Number.isFinite(b) ? b : 0;\n\n            const [lr, lg, lb] = this._srgbToLinear([r, g, b]);\n            const [X, Y, Z] = this._linearToXyz([lr, lg, lb]);\n            const lab = this._xyzToLab(X, Y, Z);\n\n            this.cache.set(key, lab);\n            return lab;\n        }\n\n        labToRgb(L, a, b_lab) { // Renamed b parameter\n            const key = `lab-${L}-${a}-${b_lab}`;\n            if (this.cache.has(key)) return this.cache.get(key);\n\n            L = Number.isFinite(L) ? L : 0;\n            a = Number.isFinite(a) ? a : 0;\n            b_lab = Number.isFinite(b_lab) ? b_lab : 0;\n\n            const { X, Y, Z } = this._labToXyz(L, a, b_lab);\n            const [lr, lg, lb] = this._xyzToLinear(X, Y, Z);\n            const [r, g, b] = this._linearToSrgb([lr, lg, lb]);\n\n            const rgb = { r, g, b };\n            this.cache.set(key, rgb);\n            return rgb;\n        }\n\n        // --- Private Helpers ---\n\n        _srgbToLinear(rgbArray) {\n            return rgbArray.map(v => {\n                v /= 255.0; // Use float division\n                return (v <= 0.04045) ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n            });\n        }\n\n        _linearToSrgb(linearArray) {\n            return linearArray.map(v => {\n                v = Math.max(0.0, Math.min(1.0, v)); // Clamp linear value 0-1\n                let ret;\n                if (v <= 0.0031308) {\n                    ret = v * 12.92;\n                } else {\n                    ret = 1.055 * Math.pow(v, 1.0 / 2.4) - 0.055;\n                }\n                // Final clamp 0-1 and round to 0-255\n                return Math.round(Math.max(0.0, Math.min(1.0, ret)) * 255.0);\n            });\n        }\n\n        _linearToXyz(linearArray) {\n            const [lr, lg, lb] = linearArray;\n            // sRGB D65 matrix (standard coefficients)\n            const X = lr * 0.4124564 + lg * 0.3575761 + lb * 0.1804375;\n            const Y = lr * 0.2126729 + lg * 0.7151522 + lb * 0.0721750;\n            const Z = lr * 0.0193339 + lg * 0.1191920 + lb * 0.9503041;\n            return [X, Y, Z];\n        }\n\n        _xyzToLinear(X, Y, Z) {\n            // Ensure non-negative before matrix multiplication\n            X = Math.max(0.0, X); Y = Math.max(0.0, Y); Z = Math.max(0.0, Z);\n            // Inverse sRGB D65 matrix (standard coefficients)\n            const lr =  3.2404542 * X - 1.5371385 * Y - 0.4985314 * Z;\n            const lg = -0.9692660 * X + 1.8760108 * Y + 0.0415560 * Z;\n            const lb =  0.0556434 * X - 0.2040259 * Y + 1.0572252 * Z;\n            return [lr, lg, lb];\n        }\n\n        _xyzToLab(X, Y, Z) {\n            const { X: Xn, Y: Yn, Z: Zn } = this.WHITE_REFERENCE;\n            // Ensure non-negative before division\n            X = Math.max(0.0, X); Y = Math.max(0.0, Y); Z = Math.max(0.0, Z);\n\n            const xr = X / Xn, yr = Y / Yn, zr = Z / Zn;\n\n            const fx = (xr > this.epsilon) ? Math.cbrt(xr) : (this.kappa * xr + 16.0) / 116.0;\n            const fy = (yr > this.epsilon) ? Math.cbrt(yr) : (this.kappa * yr + 16.0) / 116.0;\n            const fz = (zr > this.epsilon) ? Math.cbrt(zr) : (this.kappa * zr + 16.0) / 116.0;\n\n            const L = (116.0 * fy) - 16.0;\n            const a = 500.0 * (fx - fy);\n            const b = 200.0 * (fy - fz);\n\n            return { L, a, b };\n        }\n\n        _labToXyz(L, a, b_lab) {\n            const fy = (L + 16.0) / 116.0;\n            const fx = a / 500.0 + fy;\n            const fz = fy - b_lab / 200.0;\n\n            const fx3 = fx ** 3;\n            const fz3 = fz ** 3;\n\n            const xr = (fx3 > this.epsilon) ? fx3 : (116.0 * fx - 16.0) / this.kappa;\n            // Corrected calculation for yr based on L directly when below threshold\n            const yr = (L > this.kappa * this.epsilon) ? ((L + 16.0) / 116.0) ** 3 : L / this.kappa;\n            const zr = (fz3 > this.epsilon) ? fz3 : (116.0 * fz - 16.0) / this.kappa;\n\n            const { X: Xn, Y: Yn, Z: Zn } = this.WHITE_REFERENCE;\n            // Ensure non-negative results\n            return {\n                X: Math.max(0.0, xr * Xn),\n                Y: Math.max(0.0, yr * Yn),\n                Z: Math.max(0.0, zr * Zn)\n            };\n        }\n    }\n\n\n    /*****************************************************\n     * Logging Helper\n     *****************************************************/\n    function logWithTimestamp(message, ...args) {\n        const time = performance.now().toFixed(1); // Time in ms since page load\n        console.log(`[${time}ms] ${message}`, ...args);\n    }\n\n    /*****************************************************\n     * 2) Delta E (CIE76) & Helpers\n     *****************************************************/\n    function deltaE76(lab1, lab2) {\n        if (!lab1 || !lab2) return Infinity;\n        const dL = lab1.L - lab2.L;\n        const da = lab1.a - lab2.a;\n        const db = lab1.b - lab2.b;\n        return Math.sqrt(dL * dL + da * da + db * db);\n    }\n\n    function clamp(value, min = 0, max = 255) {\n        return Math.max(min, Math.min(value, max));\n    }\n\n    // --- Vector Math Helpers for LAB ---\n    function vecDot(vA, vB) { return (vA.L * vB.L) + (vA.a * vB.a) + (vA.b * vB.b); }\n    function vecSub(vA, vB) { return { L: vA.L - vB.L, a: vA.a - vB.a, b: vA.b - vB.b }; }\n    function vecAdd(vA, vB) { return { L: vA.L + vB.L, a: vA.a + vB.a, b: vA.b + vB.b }; }\n    function vecScale(vA, scalar) { return { L: vA.L * scalar, a: vA.a * scalar, b: vA.b * scalar }; }\n    function vecMagSq(vA) { return vecDot(vA, vA); }\n\n    /**\n     * Finds the closest point M on the line segment P1-P2 to point O.\n     * Returns { pointM: {L,a,b}, weightP1: number } (weightP1 for P1)\n     */\n    function projectOntoSegment(pointO, segP1, segP2) {\n        const vecV = vecSub(segP2, segP1); // Vector P1 -> P2\n        const vecW = vecSub(pointO, segP1); // Vector P1 -> O\n        const dotVV = vecMagSq(vecV);\n\n        if (dotVV < 1e-9) { // P1 and P2 are essentially the same point\n            return { pointM: segP1, weightP1: 1.0 };\n        }\n\n        const dotWV = vecDot(vecW, vecV);\n        // t = projection factor onto infinite line P1P2 (0=P1, 1=P2)\n        const t = dotWV / dotVV;\n        const t_clamped = Math.max(0.0, Math.min(1.0, t)); // Clamp to segment [0, 1]\n\n        // Closest point M = P1 + t_clamped * V\n        const pointM = vecAdd(segP1, vecScale(vecV, t_clamped));\n        const weightP1 = 1.0 - t_clamped; // Weight for P1\n\n        return { pointM, weightP1 };\n    }\n\n    /*****************************************************\n     * 3) Nearest Color Finders\n     *****************************************************/\n    function pickNearestInLargePalette(targetLab, paletteLabs) {\n        let bestDist = Infinity;\n        let bestIdx = 0;\n        if (!targetLab || !paletteLabs || paletteLabs.length === 0) return 0;\n\n        for (let i = 0; i < paletteLabs.length; i++) {\n            const labP = paletteLabs[i];\n            if (!labP) continue; // Skip if palette entry is invalid\n            const d = deltaE76(targetLab, labP);\n            if (d < bestDist) {\n                bestDist = d;\n                bestIdx = i;\n                if (d < 0.001) break; // Early exit if essentially perfect match\n            }\n        }\n        return bestIdx;\n    }\n\n    /**\n     * Finds the palette color most directionally opposite to P1 (closestC_idx), relative to O (targetO_lab).\n     * Returns the index of the opposite color, or -1 if none found/valid.\n     */\n    function findOppositeColor(targetO_lab, closestC_idx, paletteLabs) {\n        if (paletteLabs.length < 2) return -1;\n\n        const labC = paletteLabs[closestC_idx];\n        if (!labC) return -1;\n\n        const vecOC = vecSub(labC, targetO_lab);\n        const magSqOC = vecMagSq(vecOC);\n\n        // If target is extremely close to C, finding an \"opposite\" isn't meaningful\n        if (magSqOC < 1e-9) return -1;\n\n        let oppositeIdx = -1;\n        let minCosAngle = 1.0; // Cosine range is -1 to 1, min cosine = max angle (180 deg)\n        const magOC = Math.sqrt(magSqOC); // Calculate magnitude once\n\n        for (let k = 0; k < paletteLabs.length; k++) {\n            if (k === closestC_idx) continue; // Skip the closest color itself\n\n            const labK = paletteLabs[k];\n            if (!labK) continue; // Skip invalid palette entries\n\n            const vecOk = vecSub(labK, targetO_lab);\n            const magSqOk = vecMagSq(vecOk);\n\n            if (magSqOk < 1e-9) continue; // Skip if K is same as target\n\n            const magOk = Math.sqrt(magSqOk);\n            const denominator = magOC * magOk;\n            if (denominator < 1e-9) continue; // Avoid division by zero\n\n            const cosAngle = vecDot(vecOC, vecOk) / denominator;\n            const clampedCosAngle = Math.max(-1.0, Math.min(1.0, cosAngle)); // Clamp due to float issues\n\n            if (clampedCosAngle < minCosAngle) {\n                minCosAngle = clampedCosAngle;\n                oppositeIdx = k;\n            }\n        }\n        // Optional: Add an angle threshold check if needed\n        // if (minCosAngle > -0.5) return -1; // e.g., angle must be > 120 deg\n\n        // Make sure we actually found a different index\n        if (oppositeIdx === closestC_idx) return -1;\n\n        return oppositeIdx;\n    }\n\n    /*****************************************************\n     * 4) Dithering Strategy & Algorithms\n     *****************************************************/\n\n    /**\n     * Determines the dithering strategy based on \"Nearest + Opposite (Checked)\".\n     * Returns { type: 'solid'|'dither', idx1: number, idx2?: number, weight1?: number }\n     */\n    function findDitherStrategy_NearestOpposite(originalLab, paletteLabs, colorSpace) {\n         if (!paletteLabs || paletteLabs.length === 0) {\n             console.warn(\"Strategy: Empty palette received.\");\n             return { type: 'solid', idx1: 0 }; // Handle empty\n         }\n\n         // 1. Find Closest (C)\n        const idxC = pickNearestInLargePalette(originalLab, paletteLabs);\n        const labC = paletteLabs[idxC];\n        if (!labC) { console.warn(\"Strategy: Closest color invalid.\"); return { type: 'solid', idx1: 0 }; }\n        const distC = deltaE76(originalLab, labC);\n\n        // 2. Handle perfect match or single color palette\n        if (distC < 0.001 || paletteLabs.length < 2) {\n            return { type: 'solid', idx1: idxC };\n        }\n\n        // 3. Find Most Opposite (I)\n        const idxI = findOppositeColor(originalLab, idxC, paletteLabs);\n\n        // 4. If no valid opposite found, use solid C\n        if (idxI === -1) { // findOppositeColor returns -1 if no valid opposite\n             return { type: 'solid', idx1: idxC };\n        }\n        const labI = paletteLabs[idxI];\n        if (!labI) { console.warn(\"Strategy: Opposite color invalid.\"); return { type: 'solid', idx1: idxC }; }\n\n        // 5. Perform Bracketing Check (Find closest point M on segment CI to O)\n        const { pointM, weightP1: weightC } = projectOntoSegment(originalLab, labC, labI);\n        const distM = deltaE76(originalLab, pointM);\n\n        // 6. Compare and Decide\n        if (distM < distC) {\n            // Dithering C and I is beneficial\n            return { type: 'dither', idx1: idxC, idx2: idxI, weight1: clamp(weightC, 0, 1) };\n        } else {\n            // Solid C is better or equal\n            return { type: 'solid', idx1: idxC };\n        }\n    }\n\n    /**\n     * Applies dither using the \"Nearest + Opposite (Checked)\" strategy.\n     */\n    function ditherNearestOppositeChecked(\n        imageData, palette, paletteLabs, colorSpace, blueNoiseTextureData\n    ) {\n        logWithTimestamp(\"ditherNearestOppositeChecked started\");\n        const startTime = performance.now();\n        const { width, height, data } = imageData;\n        if (!blueNoiseTextureData) {\n            console.warn(\"Blue noise texture missing. Applying no dithering.\");\n            return doNoDitherLargePalette(imageData, palette, paletteLabs, colorSpace);\n        }\n        const { width: bnWidth, height: bnHeight, data: bnData } = blueNoiseTextureData;\n        const output = new Uint8ClampedArray(data.length);\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const i4 = (y * width + x) * 4;\n                const r = data[i4], g = data[i4 + 1], b = data[i4 + 2], a = data[i4 + 3];\n                const originalLab = colorSpace.rgbToLab(r, g, b);\n\n                // Determine strategy for this pixel\n                const strategy = findDitherStrategy_NearestOpposite(originalLab, paletteLabs, colorSpace);\n\n                let chosenIdx;\n\n                if (strategy.type === 'solid') {\n                    chosenIdx = strategy.idx1;\n                } else { // type === 'dither'\n                    // Get blue noise value\n                    const bnX = x % bnWidth, bnY = y % bnHeight;\n                    const bnIndex = (bnY * bnWidth + bnX) * 4;\n                    const bnValue = bnData[bnIndex] / 255.0; // Use Red channel\n\n                    // Threshold using calculated weight for P1 (closest color C)\n                    chosenIdx = (bnValue < strategy.weight1) ? strategy.idx1 : strategy.idx2;\n                }\n\n                // Safety check for chosen index before accessing palette\n                if (chosenIdx < 0 || chosenIdx >= palette.length) {\n                    console.error(`Invalid chosen index ${chosenIdx} at ${x},${y}. Defaulting to 0.`);\n                    chosenIdx = 0;\n                }\n\n                // Get output color RGB\n                const { r: qr, g: qg, b: qb } = colorSpace.hexToRgb(palette[chosenIdx]);\n                output[i4] = qr; output[i4 + 1] = qg; output[i4 + 2] = qb; output[i4 + 3] = a;\n            }\n        }\n        const endTime = performance.now();\n        logWithTimestamp(`ditherNearestOppositeChecked finished in ${(endTime - startTime).toFixed(1)}ms`);\n        return new ImageData(output, width, height);\n    }\n\n    /**\n     * \"No dithering\": single nearest color in palette.\n     */\n    function doNoDitherLargePalette(imageData, palette, paletteLabs, colorSpace) {\n        logWithTimestamp(\"doNoDitherLargePalette started\");\n        const startTime = performance.now();\n        const { width, height, data } = imageData; const outArr = new Uint8ClampedArray(data.length);\n        for (let i = 0; i < data.length; i += 4) {\n            const r=data[i],g=data[i+1],b=data[i+2],a=data[i+3]; const labPix=colorSpace.rgbToLab(r,g,b);\n            const idx=pickNearestInLargePalette(labPix,paletteLabs); const safeIdx=(idx>=0&&idx<palette.length)?idx:0;\n            if (idx !== safeIdx) console.warn(`Invalid index ${idx} from pickNearest. Defaulting to 0.`);\n            const { r: qr, g: qg, b: qb } = colorSpace.hexToRgb(palette[safeIdx]);\n            outArr[i]=qr;outArr[i+1]=qg;outArr[i+2]=qb;outArr[i+3]=a;\n        }\n        const endTime = performance.now();\n        logWithTimestamp(`doNoDitherLargePalette finished in ${(endTime - startTime).toFixed(1)}ms`);\n        return new ImageData(outArr, width, height);\n    }\n\n    /**\n     * Applies Gamma, Contrast, Saturation adjustments.\n     */\n     function applyImageAdjustments(sourceImageData, adjustments) {\n        logWithTimestamp(\"applyImageAdjustments started\", adjustments);\n        const startTime = performance.now();\n        if (!sourceImageData) return null; const { gamma, contrast, saturation } = adjustments; const gammaExponent = gamma === 0 ? Infinity : 1.0 / gamma;\n        const { width, height, data } = sourceImageData; const newData = new Uint8ClampedArray(data); const lumR=0.2126,lumG=0.7152,lumB=0.0722;\n        for (let i=0;i<newData.length;i+=4) { let r=data[i],g=data[i+1],b=data[i+2];\n            if(saturation!==1.0){const gray=r*lumR+g*lumG+b*lumB; r=clamp(gray+saturation*(r-gray));g=clamp(gray+saturation*(g-gray));b=clamp(gray+saturation*(b-gray));}\n            if(contrast!==1.0){r=clamp(((r/255.0-0.5)*contrast+0.5)*255.0);g=clamp(((g/255.0-0.5)*contrast+0.5)*255.0);b=clamp(((b/255.0-0.5)*contrast+0.5)*255.0);}\n            if(gamma!==1.0&&gamma>0){r=clamp(Math.pow(r/255.0,gammaExponent)*255.0);g=clamp(Math.pow(g/255.0,gammaExponent)*255.0);b=clamp(Math.pow(b/255.0,gammaExponent)*255.0);}\n            newData[i]=Math.round(r); newData[i+1]=Math.round(g); newData[i+2]=Math.round(b);\n        }\n        const endTime = performance.now();\n        logWithTimestamp(`applyImageAdjustments finished in ${(endTime - startTime).toFixed(1)}ms`);\n        return new ImageData(newData, width, height);\n    }\n\n    /*****************************************************\n     * 5) Main Application Logic & UI\n     *****************************************************/\n\n    // --- State Variables ---\n    const colorSpace = new ColorSpaceConverter();\n    let originalFileName = \"image\";\n    let originalImageData = null;\n    let previewImageData = null;\n    let currentImageData = null;\n    let blueNoiseTextureData = null;\n    let isProcessing = false;\n    let isEyedropperActive = false;\n    let customPaletteArray = ['#000000', '#FFFFFF'];\n\n    // --- UI Element References ---\n    let uiElements = {};\n    try {\n         uiElements = {\n            fileInput: document.getElementById(\"image-input\"),\n            paletteSelect: document.getElementById(\"palette-select\"),\n            customPaletteTools: document.getElementById(\"custom-palette-tools\"),\n            customColorPicker: document.getElementById(\"custom-color-picker\"),\n            customHexInput: document.getElementById(\"custom-hex-input\"),\n            addColorButton: document.getElementById(\"add-color-button\"),\n            paletteSwatchDisplay: document.getElementById(\"palette-swatch-display\"),\n            gammaSlider: document.getElementById(\"gamma-slider\"),\n            gammaValueSpan: document.getElementById(\"gamma-value\"),\n            contrastSlider: document.getElementById(\"contrast-slider\"),\n            contrastValueSpan: document.getElementById(\"contrast-value\"),\n            saturationSlider: document.getElementById(\"saturation-slider\"),\n            saturationValueSpan: document.getElementById(\"saturation-value\"),\n            resetAdjustmentsButton: document.getElementById(\"reset-adjustments-button\"),\n            ditheringEnabledCheckbox: document.getElementById(\"dithering-enable\"),\n            processButton: document.getElementById(\"process-button\"),\n            undoButton: document.getElementById(\"undo-button\"),\n            downloadButton: document.getElementById(\"download-button\"),\n            canvas: document.getElementById(\"canvas\"),\n            ctx: document.getElementById(\"canvas\")?.getContext(\"2d\", { willReadFrequently: true }),\n            statusMessage: document.getElementById(\"status-message\"),\n            paletteFileInput: document.getElementById(\"palette-file-input\"),\n            eyedropperButton: document.getElementById(\"eyedropper-button\")\n        };\n        logWithTimestamp(\"INITIAL REF CHECK - paletteSelect:\", uiElements.paletteSelect ? 'Found' : 'MISSING!');\n        logWithTimestamp(\"INITIAL REF CHECK - customPaletteTools:\", uiElements.customPaletteTools ? 'Found' : 'MISSING!');\n        logWithTimestamp(\"INITIAL REF CHECK - canvas:\", uiElements.canvas ? 'Found' : 'MISSING!');\n        logWithTimestamp(\"INITIAL REF CHECK - ctx:\", uiElements.ctx ? 'Found' : 'MISSING!');\n        if (!uiElements.canvas || !uiElements.ctx || !uiElements.fileInput || !uiElements.paletteSelect || !uiElements.processButton || !uiElements.paletteSwatchDisplay) {\n             throw new Error(\"One or more core UI elements could not be found! Check HTML IDs.\");\n        }\n    } catch (error) { /* ... keep fatal error handling ... */ }\n\n    // --- Predefined Palettes ---\n    const predefined = {\n      \"1bit\": [\"#000000\", \"#FFFFFF\"],\n  \"2bit\": [\"#000000\", \"#555555\", \"#AAAAAA\", \"#FFFFFF\"],\n  \"3bit\": [\n    \"#000000\", \"#FF0000\", \"#00FF00\", \"#FFFF00\",\n    \"#0000FF\", \"#FF00FF\", \"#00FFFF\", \"#FFFFFF\"\n  ],\n  \"3bit-gray\": [\n    \"#000000\", \"#242424\", \"#484848\", \"#6C6C6C\",\n    \"#909090\", \"#B4B4B4\", \"#D8D8D8\", \"#FFFFFF\"\n  ],\n  \"nes\": [\n    \"#7C7C7C\", \"#0000FC\", \"#0000BC\", \"#4428BC\",\n    \"#940084\", \"#A80020\", \"#A81000\", \"#881400\",\n    \"#503000\", \"#007800\", \"#006800\", \"#005800\",\n    \"#004058\", \"#000000\", \"#F8F8F8\", \"#FFFFFF\"\n  ],\n  \"gameboy\": [\"#0F380F\", \"#306230\", \"#8BAC0F\", \"#9BBC0F\"],\n  \"primaries\": [\"#000000\", \"#FFFFFF\", \"#FF0000\", \"#00FF00\", \"#0000FF\"],\n  \"pastel\": [\n    \"#FFC0CB\", \"#E6E6FA\", \"#ADD8E6\",\n    \"#98FF98\", \"#FFFFE0\", \"#FFDAB9\"\n  ],\n  \"ggost\": [\n    \"#000000\", \"#1E2223\", \"#224AC4\", \"#6245B9\", \"#65A3EC\",\n    \"#6AB960\", \"#8B897D\", \"#9C3B35\", \"#B8C0C3\", \"#C56B60\",\n    \"#F88127\", \"#FB5A9E\", \"#FBDF2B\", \"#FCC292\", \"#FD432A\",\n    \"#FDE6C4\", \"#FFFFFF\"\n  ]\n};\n\n    // --- Helper Functions ---\n    function showStatus(message) { if (uiElements.statusMessage) uiElements.statusMessage.textContent = message; }\n    function formatHex(hexString) { if (!hexString) return null; let h=hexString.trim(); if(!h.startsWith('#'))h='#'+h; if (/^#[0-9A-F]{6}$/i.test(h)) return h.toUpperCase(); if (/^#[0-9A-F]{3}$/i.test(h)) return ('#'+h[1]+h[1]+h[2]+h[2]+h[3]+h[3]).toUpperCase(); return null;}\n\n    function renderPaletteSwatches(paletteArray) {\n        logWithTimestamp(\"renderPaletteSwatches called\");\n        if (!uiElements.paletteSwatchDisplay) return;\n        uiElements.paletteSwatchDisplay.innerHTML = '';\n        const isCustomPaletteActive = (uiElements.paletteSelect.value === \"custom\");\n        // console.log(\"Rendering swatches. Is Custom Active?\", isCustomPaletteActive); // DEBUG\n\n        paletteArray.forEach((hexColor, index) => {\n            const swatch = document.createElement('div'); swatch.className = 'swatch';\n            swatch.style.backgroundColor = hexColor; swatch.title = hexColor;\n            if (isCustomPaletteActive) {\n                 // console.log(`Adding remove button for index ${index}`); // DEBUG\n                const removeBtn = document.createElement('button'); removeBtn.className = 'remove-color-btn';\n                removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${hexColor}`; removeBtn.type = 'button';\n                removeBtn.dataset.index = index;\n                removeBtn.addEventListener('click', (e) => {\n                    e.stopPropagation();\n                    logWithTimestamp(\"Remove button clicked. dataset.index:\", e.target.dataset.index); // DEBUG\n                    const indexToRemove = parseInt(e.target.dataset.index, 10);\n                    logWithTimestamp(\"Parsed index to remove:\", indexToRemove); // DEBUG\n                    if (!isNaN(indexToRemove) && indexToRemove >= 0 && indexToRemove < customPaletteArray.length) {\n                        customPaletteArray.splice(indexToRemove, 1);\n                        logWithTimestamp(\"Array after splice:\", customPaletteArray); // DEBUG\n                        renderPaletteSwatches(customPaletteArray); // Re-render\n                    } else { console.error(\"Failed to parse index or index out of bounds:\", e.target.dataset.index); }\n                });\n                swatch.appendChild(removeBtn);\n            }\n            uiElements.paletteSwatchDisplay.appendChild(swatch);\n        });\n    }\n\n    function getUserPalette() {\n        logWithTimestamp(\"getUserPalette called\");\n        const sel = uiElements.paletteSelect.value;\n        if (sel === \"custom\") { if(customPaletteArray.length===0){showStatus(\"Warning: Custom palette empty.\");return['#000000','#FFFFFF']} return [...customPaletteArray];}\n        if (predefined[sel]) return predefined[sel];\n        showStatus(\"Warning: Palette not found.\"); return [\"#000000\", \"#FFFFFF\"];\n    }\n\n    function parsePaletteFile(content, fileName) {\n        logWithTimestamp(\"parsePaletteFile called\", fileName);\n        const colors = new Set(); const lines = content.split(/[\\r\\n]+/);\n        if (fileName && fileName.toLowerCase().endsWith('.gpl')) { lines.forEach(line => { if(line.startsWith('#')||line.trim()===''||line.startsWith('GIMP Palette')||line.startsWith('Name:')||line.startsWith('Columns:'))return; const parts=line.trim().split(/\\s+/); if(parts.length>=3){const r=parseInt(parts[0],10),g=parseInt(parts[1],10),b=parseInt(parts[2],10); if(!isNaN(r)&&!isNaN(g)&&!isNaN(b)){const rH=clamp(r).toString(16).padStart(2,'0'),gH=clamp(g).toString(16).padStart(2,'0'),bH=clamp(b).toString(16).padStart(2,'0'); colors.add(`#${rH}${gH}${bH}`.toUpperCase());}}}); }\n        else { lines.forEach(line => { const parts = line.split(/[\\s,;]+/); parts.forEach(part => { const formattedHex = formatHex(part); if (formattedHex) colors.add(formattedHex); }); }); }\n        logWithTimestamp(`Parsed ${colors.size} unique colors from file.`);\n        return Array.from(colors);\n    }\n\n    // --- Image Adjustments ---\n    function updatePreview() {\n        if (!originalImageData || isProcessing || !uiElements.ctx) return;\n        logWithTimestamp(\"updatePreview started\");\n        showStatus(\"Applying adjustments...\");\n        try {\n            const adjustments = { gamma: parseFloat(uiElements.gammaSlider.value)||1, contrast: (parseFloat(uiElements.contrastSlider.value)||100)/100, saturation: (parseFloat(uiElements.saturationSlider.value)||100)/100 };\n             if (isNaN(adjustments.gamma+adjustments.contrast+adjustments.saturation)) throw new Error(\"Invalid adjustment value.\");\n            previewImageData = applyImageAdjustments(originalImageData, adjustments);\n            if (previewImageData) { uiElements.ctx.putImageData(previewImageData, 0, 0); showStatus(\"Adjustments applied to preview.\"); currentImageData = previewImageData; }\n            else { throw new Error(\"Adjustment calculation failed.\"); }\n        } catch (error) { console.error(\"Error updating preview:\", error); showStatus(`Preview Error: ${error.message}`); }\n        logWithTimestamp(\"updatePreview finished\");\n    }\n\n    // --- Loading Functions ---\n    async function loadImage(url) {\n        logWithTimestamp(\"loadImage started with URL:\", url); // DEBUG\n        if (!uiElements.ctx) { console.error(\"Canvas context (ctx) is not valid!\"); showStatus(\"Error: Canvas context failed.\"); return; }\n        showStatus(\"Loading image...\");\n        if(uiElements.processButton) uiElements.processButton.disabled = true; if(uiElements.undoButton) uiElements.undoButton.disabled = true; if(uiElements.downloadButton) uiElements.downloadButton.disabled = true;\n        try {\n            const img = new Image(); logWithTimestamp(\"Image object created.\"); // DEBUG\n            img.onerror = (errEvent) => { console.error(\"Native img.onerror fired.\", errEvent); showStatus(\"Error: Failed to load image file data.\"); }; // DEBUG\n            img.src = url; logWithTimestamp(\"img.src set to:\", url); // DEBUG\n            await new Promise((resolve, reject) => { img.onload=()=>{logWithTimestamp(\"img.onload (Promise) fired.\"); resolve()}; img.onerror=(e)=>{console.error(\"img.onerror (Promise) fired:\", e); reject(new Error(\"Image failed to load from source\"))}; });\n            logWithTimestamp(\"Image has loaded. Natural dimensions:\", img.naturalWidth, \"x\", img.naturalHeight); // DEBUG\n            if (img.naturalWidth === 0 || img.naturalHeight === 0) throw new Error(\"Image loaded but has zero dimensions.\");\n            uiElements.canvas.width = img.naturalWidth; uiElements.canvas.height = img.naturalHeight; logWithTimestamp(`Canvas resized to ${uiElements.canvas.width}x${uiElements.canvas.height}.`); // DEBUG\n            uiElements.ctx.drawImage(img, 0, 0); logWithTimestamp(\"Image drawn to canvas.\"); // DEBUG\n            originalImageData = uiElements.ctx.getImageData(0, 0, uiElements.canvas.width, uiElements.canvas.height); logWithTimestamp(\"Original image data acquired.\"); // DEBUG\n            previewImageData = originalImageData; currentImageData = originalImageData;\n            if(uiElements.resetAdjustmentsButton) uiElements.resetAdjustmentsButton.click(); else updatePreview(); // Reset sliders & update preview\n            showStatus(\"Image loaded. Adjustments reset.\");\n            if(uiElements.undoButton) uiElements.undoButton.disabled = false; if(uiElements.downloadButton) uiElements.downloadButton.disabled = false; if(uiElements.processButton) uiElements.processButton.disabled = blueNoiseTextureData === null;\n        } catch (error) { console.error(\"Error within loadImage try block:\", error); showStatus(`Error loading image: ${error.message}`); originalImageData=null; previewImageData=null; currentImageData=null; if(uiElements.processButton)uiElements.processButton.disabled=true; if(uiElements.undoButton)uiElements.undoButton.disabled=true; if(uiElements.downloadButton)uiElements.downloadButton.disabled=true; }\n        finally { if (url && url.startsWith('blob:')) { logWithTimestamp(\"Revoking object URL:\", url); URL.revokeObjectURL(url); } }\n        logWithTimestamp(\"loadImage finished\");\n    }\n\n    function loadBlueNoise() {\n        logWithTimestamp(\"loadBlueNoise started\");\n        // *** REPLACE WITH YOUR ACTUAL URL or LOCAL PATH ***\n        const blueNoiseURL = \"https://assets.codepen.io/3457130/HDR_L_0.png\"; // Example URL\n        // const blueNoiseURL = \"blue-noise-128.png\"; // Example local path\n\n        const img = new Image(); if (!blueNoiseURL.startsWith(\"data:\") && !blueNoiseURL.startsWith(window.location.origin) && !/^[./]/.test(blueNoiseURL)) img.crossOrigin = \"Anonymous\";\n        const processTexture = () => { try { logWithTimestamp(\"Processing blue noise texture...\"); const tempCanvas=document.createElement('canvas'); const tempCtx=tempCanvas.getContext('2d'); tempCanvas.width=img.naturalWidth; tempCanvas.height=img.naturalHeight; if(tempCanvas.width===0||tempCanvas.height===0)throw new Error(`Texture loaded with zero dimensions.`); tempCtx.drawImage(img,0,0); blueNoiseTextureData=tempCtx.getImageData(0,0,tempCanvas.width,tempCanvas.height); logWithTimestamp(`Blue noise texture (${tempCanvas.width}x${tempCanvas.height}) processed successfully.`); if(uiElements.processButton)uiElements.processButton.disabled=originalImageData===null;} catch(error){ console.error(\"Error processing blue noise texture:\", error); let dE=error.message; if(error.name==='SecurityError')dE+=' CORS issue?'; showStatus(`Error processing BN texture: ${dE}`); alert(`Error processing BN texture: ${dE}`); if(uiElements.processButton)uiElements.processButton.disabled = true;} };\n        img.onload = processTexture; img.onerror = (err) => { console.error(`Error loading blue noise texture from ${blueNoiseURL}:`, err); const msg=`Error loading BN texture. Check URL/path & network.`; showStatus(msg); alert(msg); if(uiElements.processButton)uiElements.processButton.disabled = true;};\n        img.src = blueNoiseURL;\n        logWithTimestamp(\"loadBlueNoise: Image source set, loading initiated.\");\n    }\n\n    // --- Event Listeners Setup ---\n    logWithTimestamp(\"Setting up event listeners...\");\n    try { // Wrap listener setup in try/catch for better debugging if uiElements missing\n        if (uiElements.fileInput) uiElements.fileInput.addEventListener(\"change\", (e) => {\n            logWithTimestamp(\"fileInput 'change' event\");\n            const file = e.target.files[0]; logWithTimestamp(\"Selected file object:\", file);\n            if (!file) { logWithTimestamp(\"No file selected.\"); return; }\n            originalFileName = file.name.replace(/\\.[^/.]+$/, \"\"); const url = URL.createObjectURL(file); logWithTimestamp(\"Created object URL:\", url);\n            try { loadImage(url); logWithTimestamp(\"loadImage(url) function called successfully.\"); } catch(callError) { console.error(\"Error calling loadImage:\", callError); showStatus(\"Error trying to load image.\"); }\n            uiElements.fileInput.value = null;\n        });\n\n        if (uiElements.paletteFileInput) uiElements.paletteFileInput.addEventListener('change', (e) => {\n            logWithTimestamp(\"paletteFileInput 'change' event\");\n            const file = e.target.files[0]; if (!file) return; showStatus(`Reading palette file: ${file.name}...`); const reader = new FileReader();\n            reader.onload = (event) => { try { const fileContent = event.target.result; const newPalette = parsePaletteFile(fileContent, file.name); if (newPalette && newPalette.length > 0) { customPaletteArray = newPalette; renderPaletteSwatches(customPaletteArray); if(uiElements.paletteSelect){uiElements.paletteSelect.value='custom';uiElements.paletteSelect.dispatchEvent(new Event('change'));} showStatus(`Loaded ${newPalette.length} colors from ${file.name}.`); } else { showStatus(`Could not parse colors from ${file.name}.`); } } catch (error) { console.error(\"Error parsing palette file:\", error); showStatus(`Error parsing file: ${error.message}`); alert(`Error parsing file: ${error.message}`); } finally { uiElements.paletteFileInput.value = null; } };\n            reader.onerror = () => { console.error(\"Error reading file:\", reader.error); showStatus(`Error reading file: ${reader.error}`); alert(`Error reading file: ${reader.error}`); uiElements.paletteFileInput.value = null; }; reader.readAsText(file);\n        });\n\n        if (uiElements.paletteSelect) uiElements.paletteSelect.addEventListener(\"change\", () => {\n            logWithTimestamp(\">>> Palette 'change' listener FIRED. Value:\", uiElements.paletteSelect.value);\n            if (!uiElements.customPaletteTools) { console.error(\"Listener: customPaletteTools is null!\"); return; }\n            const isCustom = (uiElements.paletteSelect.value === \"custom\");\n            logWithTimestamp(\"Listener: isCustom evaluated to:\", isCustom);\n            uiElements.customPaletteTools.style.display = isCustom ? \"block\" : \"none\";\n            logWithTimestamp(\"Listener: Set customPaletteTools display to:\", uiElements.customPaletteTools.style.display);\n            renderPaletteSwatches(getUserPalette());\n        });\n\n        if (uiElements.customColorPicker) uiElements.customColorPicker.addEventListener('input', (e) => { if(uiElements.customHexInput) {uiElements.customHexInput.value = e.target.value.toUpperCase(); uiElements.customHexInput.style.borderColor = '';} });\n        if (uiElements.customHexInput) uiElements.customHexInput.addEventListener('input', (e) => { const fH=formatHex(e.target.value); if(fH){if(uiElements.customColorPicker)uiElements.customColorPicker.value=fH; e.target.value=fH; e.target.style.borderColor='';} else {e.target.style.borderColor='red';}});\n        if (uiElements.addColorButton) uiElements.addColorButton.addEventListener('click', () => {\n            logWithTimestamp(\"addColorButton 'click' event\"); const newHexColor = formatHex(uiElements.customHexInput.value); logWithTimestamp(\"Formatted Hex for Add:\", newHexColor); if (newHexColor) { if (!customPaletteArray.includes(newHexColor)) { customPaletteArray.push(newHexColor); logWithTimestamp(\"Added. New customPaletteArray:\", customPaletteArray); renderPaletteSwatches(customPaletteArray); uiElements.customHexInput.style.borderColor=''; } else { showStatus(`${newHexColor} already in palette.`); logWithTimestamp(\"Color already exists.\"); } } else { showStatus(\"Invalid hex code entered.\"); logWithTimestamp(\"Invalid hex for Add.\"); uiElements.customHexInput.style.borderColor='red'; }\n        });\n\n        if (uiElements.eyedropperButton) uiElements.eyedropperButton.addEventListener('click', () => {\n            logWithTimestamp(\"eyedropperButton 'click' event\"); isEyedropperActive = !isEyedropperActive; if (isEyedropperActive) { showStatus(\"Eyedropper active: Click on image preview.\"); uiElements.canvas.classList.add('eyedropper-active'); uiElements.eyedropperButton.textContent = \"Cancel Eyedropper\"; uiElements.eyedropperButton.style.borderColor='red'; } else { showStatus(\"Eyedropper deactivated.\"); uiElements.canvas.classList.remove('eyedropper-active'); uiElements.eyedropperButton.textContent = \"Pick Color from Image (Eyedropper)\"; uiElements.eyedropperButton.style.borderColor=''; }\n        });\n        if (uiElements.canvas) uiElements.canvas.addEventListener('click', (event) => {\n            if (!isEyedropperActive) return; logWithTimestamp(\"canvas 'click' event (eyedropper active)\"); const iDTS = previewImageData || originalImageData; if (!iDTS) return; const rect = uiElements.canvas.getBoundingClientRect(); const sX = uiElements.canvas.width/rect.width; const sY = uiElements.canvas.height/rect.height; const cX = Math.floor((event.clientX-rect.left)*sX); const cY = Math.floor((event.clientY-rect.top)*sY); if(cX<0||cX>=uiElements.canvas.width||cY<0||cY>=uiElements.canvas.height)return; const pI=(cY*uiElements.canvas.width+cX)*4; const r=iDTS.data[pI],g=iDTS.data[pI+1],b=iDTS.data[pI+2]; const rH=r.toString(16).padStart(2,'0'),gH=g.toString(16).padStart(2,'0'),bH=b.toString(16).padStart(2,'0'); const pH=`#${rH}${gH}${bH}`.toUpperCase(); if(uiElements.customColorPicker) uiElements.customColorPicker.value=pH; if(uiElements.customHexInput) { uiElements.customHexInput.value=pH; uiElements.customHexInput.style.borderColor=''; } showStatus(`Picked color: ${pH}`); isEyedropperActive=false; uiElements.canvas.classList.remove('eyedropper-active'); if(uiElements.eyedropperButton) { uiElements.eyedropperButton.textContent=\"Pick Color from Image (Eyedropper)\"; uiElements.eyedropperButton.style.borderColor=''; }\n        });\n\n        if (uiElements.gammaSlider) uiElements.gammaSlider.addEventListener('input', () => { if(uiElements.gammaValueSpan) uiElements.gammaValueSpan.textContent = parseFloat(uiElements.gammaSlider.value).toFixed(1); updatePreview(); });\n        if (uiElements.contrastSlider) uiElements.contrastSlider.addEventListener('input', () => { if(uiElements.contrastValueSpan) uiElements.contrastValueSpan.textContent = `${uiElements.contrastSlider.value}%`; updatePreview(); });\n        if (uiElements.saturationSlider) uiElements.saturationSlider.addEventListener('input', () => { if(uiElements.saturationValueSpan) uiElements.saturationValueSpan.textContent = `${uiElements.saturationSlider.value}%`; updatePreview(); });\n        if (uiElements.resetAdjustmentsButton) uiElements.resetAdjustmentsButton.addEventListener('click', () => { logWithTimestamp(\"resetAdjustmentsButton 'click' event\"); uiElements.gammaSlider.value=1.0; uiElements.contrastSlider.value=100; uiElements.saturationSlider.value=100; if(uiElements.gammaValueSpan)uiElements.gammaValueSpan.textContent='1.0'; if(uiElements.contrastValueSpan)uiElements.contrastValueSpan.textContent='100%'; if(uiElements.saturationValueSpan)uiElements.saturationValueSpan.textContent='100%'; updatePreview(); showStatus(\"Adjustments reset.\"); });\n\n        if (uiElements.processButton) uiElements.processButton.addEventListener(\"click\", () => {\n            logWithTimestamp(\"processButton 'click' event\"); const iDTP = previewImageData || originalImageData; if (!iDTP) { showStatus(\"Please load an image first.\"); return; } const iDE = uiElements.ditheringEnabledCheckbox.checked; if (iDE && !blueNoiseTextureData) { showStatus(\"Blue noise texture not loaded. Cannot dither.\"); return; } if (isProcessing) { showStatus(\"Already processing...\"); return; }\n            isProcessing=true; showStatus(\"Processing image...\"); uiElements.processButton.disabled=true; uiElements.undoButton.disabled=true; uiElements.downloadButton.disabled=true; if(uiElements.canvas.parentElement) uiElements.canvas.parentElement.classList.add(\"processing\");\n            setTimeout(() => { try { const palette = getUserPalette(); if (palette.length === 0) throw new Error(\"Palette is empty.\"); const pL = palette.map(h => { const rgb=colorSpace.hexToRgb(h); return colorSpace.rgbToLab(rgb.r,rgb.g,rgb.b); }); let oID; const sT=performance.now(); if (iDE) { oID = ditherNearestOppositeChecked(iDTP, palette, pL, colorSpace, blueNoiseTextureData); } else { oID = doNoDitherLargePalette(iDTP, palette, pL, colorSpace); } const eT=performance.now(); showStatus(`Processing finished in ${((eT-sT)/1000).toFixed(2)}s.`); uiElements.ctx.putImageData(oID,0,0); currentImageData=oID; } catch (error) { console.error(\"Error during processing:\",error); showStatus(`Error: ${error.message}. Reverting preview.`); alert(`Processing Error: ${error.message}`); const iTR=previewImageData||originalImageData; if(iTR&&uiElements.ctx)uiElements.ctx.putImageData(iTR,0,0); currentImageData=iTR; } finally { isProcessing=false; if(uiElements.processButton) uiElements.processButton.disabled=blueNoiseTextureData===null||originalImageData===null; if(uiElements.undoButton) uiElements.undoButton.disabled=originalImageData===null; if(uiElements.downloadButton) uiElements.downloadButton.disabled=currentImageData===null; if(uiElements.canvas.parentElement) uiElements.canvas.parentElement.classList.remove(\"processing\"); logWithTimestamp(\"Processing finished (in finally block)\"); } }, 50);\n        });\n\n        if (uiElements.undoButton) uiElements.undoButton.addEventListener(\"click\", () => {\n            logWithTimestamp(\"undoButton 'click' event\"); const iTR=previewImageData||originalImageData; if(iTR){showStatus(\"Last processing undone. Showing current preview.\"); uiElements.ctx.putImageData(iTR,0,0); currentImageData=iTR; if(uiElements.downloadButton)uiElements.downloadButton.disabled=currentImageData===null;} else {showStatus(\"No image data to restore to.\");}\n        });\n\n        if (uiElements.downloadButton) uiElements.downloadButton.addEventListener(\"click\", () => {\n            logWithTimestamp(\"downloadButton 'click' event\"); if (!currentImageData) { showStatus(\"No processed image to download.\"); return; } const dM=uiElements.ditheringEnabledCheckbox.checked?\"dither_on\":\"dither_off\"; const pC=uiElements.paletteSelect.value; const fN=`${originalFileName}_quant_${pC}_${dM}.png`; const tC=document.createElement(\"canvas\"); tC.width=currentImageData.width; tC.height=currentImageData.height; const tCtx=tC.getContext(\"2d\"); tCtx.putImageData(currentImageData,0,0); try { const link=document.createElement(\"a\"); link.download=fN; link.href=tC.toDataURL(\"image/png\"); link.click(); showStatus(`Download started: ${fN}`); } catch (error) { console.error(\"Error generating download link:\",error); showStatus(`Error generating download: ${error.message}`); alert(`Error generating download: ${error.message}`); }\n        });\n\n        logWithTimestamp(\"Event listeners setup finished.\");\n\n    } catch (error) {\n        console.error(\"Error setting up event listeners:\", error);\n        showStatus(`Error during setup: ${error.message}`);\n        alert(`Application setup error: ${error.message}`);\n    }\n\n    // --- Initial Setup ---\n    function initializeApp() {\n        logWithTimestamp(\"initializeApp started\");\n        showStatus(\"Initializing application...\");\n        if (uiElements.processButton) uiElements.processButton.disabled = true; if (uiElements.undoButton) uiElements.undoButton.disabled = true; if (uiElements.downloadButton) uiElements.downloadButton.disabled = true;\n        if (!uiElements.paletteSelect || !uiElements.paletteSwatchDisplay) { console.error(\"Cannot initialize: paletteSelect or paletteSwatchDisplay missing.\"); showStatus(\"Initialization failed.\"); return; }\n        renderPaletteSwatches(customPaletteArray);\n        logWithTimestamp(\"initializeApp: Checking paletteSelect before dispatch:\", uiElements.paletteSelect); // DEBUG\n        if (uiElements.paletteSelect) { logWithTimestamp(\"initializeApp: Dispatching 'change' event...\"); uiElements.paletteSelect.dispatchEvent(new Event('change')); logWithTimestamp(\"initializeApp: 'change' event dispatched.\"); } // DEBUG\n        else { console.error(\"initializeApp: Cannot dispatch event, paletteSelect is null.\"); } // DEBUG\n        loadBlueNoise(); // Start loading texture\n        logWithTimestamp(\"initializeApp finished\");\n    }\n\n    initializeApp(); // Run setup\n\n})(); // End of main IIFE";
export const TOOL_FUNCTIONS = Object.fromEntries(TOOL_FUNCTION_NAMES.map((n) => [n, null]));
