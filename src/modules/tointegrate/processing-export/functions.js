// Extracted metadata module (safe text representation)
export const TOOL_SOURCE_PATH = "toIntegrate/processing-export/processing-export/src/index.html";
export const TOOL_EXTRACTION_MODE = "regex-only";
export const TOOL_FUNCTION_NAMES = [
  "if",
  "setup",
  "draw",
  "sketch"
];
export const TOOL_REGEX_FUNCTION_NAMES = [
  "if",
  "setup",
  "draw",
  "sketch"
];
export const TOOL_LLM_FUNCTION_NAMES = [];
export const TOOL_LLM_CAPABILITIES = [];
export const TOOL_LLM_NOTES = "";
export const TOOL_SOURCE_TEXT = "\n\n\n        class FrameCapture {\n            constructor(width, height, framerate, frameCount) {\n                this.width = width;\n                this.height = height;\n                this.framerate = framerate;\n                this.frameCount = frameCount;\n                this.frames = [];\n                this.isRecording = false;\n            }\n\n            reset() {\n                this.frames = [];\n            }\n\n            addFrame(canvas) {\n                if (this.frames.length < this.frameCount) {\n                    this.frames.push(canvas.getContext('2d').getImageData(0, 0, this.width, this.height));\n                }\n            }\n\n            isComplete() {\n                return this.frames.length >= this.frameCount;\n            }\n\n            getFrameCount() {\n                return this.frames.length;\n            }\n\n            async generateGIF() {\n                return new Promise((resolve) => {\n                    const gif = new GIF({\n                        workers: 2,\n                        quality: 10,\n                        width: this.width,\n                        height: this.height,\n                        workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'\n                    });\n\n                    const frameDuration = 1000 / this.framerate;\n\n                    this.frames.forEach(imageData => {\n                        const canvas = document.createElement('canvas');\n                        canvas.width = this.width;\n                        canvas.height = this.height;\n                        const ctx = canvas.getContext('2d');\n                        ctx.putImageData(imageData, 0, 0);\n                        gif.addFrame(canvas, { delay: frameDuration });\n                    });\n\n                    gif.on('finished', (blob) => {\n                        resolve(blob);\n                    });\n\n                    gif.render();\n                });\n            }\n        }\n\n        class CodeManager {\n            constructor() {\n                this.userSetup = null;\n                this.userDraw = null;\n            }\n\n            parseCode(code) {\n                try {\n                    // Try multiple patterns for setup function\n                    const setupPatterns = [\n                        /function\\s+setup\\s*\\(\\s*\\)\\s*\\{([\\s\\S]*?)\\n\\}/,\n                        /setup\\s*=\\s*function\\s*\\(\\s*\\)\\s*\\{([\\s\\S]*?)\\}/,\n                        /const\\s+setup\\s*=\\s*\\([^)]*\\)\\s*=>\\s*\\{([\\s\\S]*?)\\}/,\n                        /setup\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{([\\s\\S]*?)\\}/\n                    ];\n\n                    // Try multiple patterns for draw function\n                    const drawPatterns = [\n                        /function\\s+draw\\s*\\(\\s*\\)\\s*\\{([\\s\\S]*)\\}$/m,\n                        /draw\\s*=\\s*function\\s*\\(\\s*\\)\\s*\\{([\\s\\S]*)\\}$/m,\n                        /const\\s+draw\\s*=\\s*\\([^)]*\\)\\s*=>\\s*\\{([\\s\\S]*)\\}$/m,\n                        /draw\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{([\\s\\S]*)\\}$/m\n                    ];\n\n                    let setupBody = null;\n                    let drawBody = null;\n\n                    // Find setup\n                    for (let pattern of setupPatterns) {\n                        const match = code.match(pattern);\n                        if (match) {\n                            setupBody = match[1];\n                            break;\n                        }\n                    }\n\n                    // Find draw\n                    for (let pattern of drawPatterns) {\n                        const match = code.match(pattern);\n                        if (match) {\n                            drawBody = match[1];\n                            break;\n                        }\n                    }\n\n                    // If no draw found, treat entire code as draw\n                    if (!drawBody) {\n                        drawBody = code;\n                    }\n\n                    // Create setup function\n                    if (setupBody) {\n                        this.userSetup = new Function('p', setupBody);\n                    } else {\n                        this.userSetup = new Function('p', '');\n                    }\n\n                    // Create draw function\n                    this.userDraw = new Function('p', 'ui', drawBody);\n\n                    return true;\n                } catch (error) {\n                    throw new Error(`Parse error: ${error.message}`);\n                }\n            }\n\n            getSetupFunction() {\n                return this.userSetup;\n            }\n\n            getDrawFunction() {\n                return this.userDraw;\n            }\n        }\n\n        class UIController {\n            constructor() {\n                this.framerateInput = document.getElementById('framerate');\n                this.frameCountInput = document.getElementById('frameCount');\n                this.durationInput = document.getElementById('duration');\n                this.recordBtn = document.getElementById('recordBtn');\n                this.downloadBtn = document.getElementById('downloadBtn');\n                this.status = document.getElementById('status');\n\n                this.codeInput = document.getElementById('codeInput');\n                this.loadCodeBtn = document.getElementById('loadCodeBtn');\n                this.errorMessage = document.getElementById('errorMessage');\n\n                this.frameCapture = null;\n                this.isRecording = false;\n                this.codeManager = new CodeManager();\n\n                this.attachListeners();\n                this.loadDefaultCode();\n            }\n\n            loadDefaultCode() {\n                const defaultCode = `// Use 'p.' prefix for all p5 functions (instance mode)\n// Supports: function setup() { } or setup = function() { }\n//           function draw() { } or draw = function() { }\n// Or just paste any p5.js draw code\n\nfunction setup() {\n    // runs once - p is available\n}\n\nfunction draw() {\n    // p5 functions available via 'p' object\n    p.background(250);\n    \n    const time = p.frameCount / 30;\n    p.stroke(0);\n    p.strokeWeight(1);\n    p.noFill();\n\n    for (let i = 0; i < 5; i++) {\n        p.beginShape();\n        for (let x = 0; x < p.width; x += 5) {\n            const y = p.height / 2 + Math.sin((x + time * 100) * 0.01 + i) * 50;\n            p.vertex(x, y);\n        }\n        p.endShape();\n    }\n}`;\n                this.codeInput.value = defaultCode;\n            }\n\n            attachListeners() {\n                this.framerateInput.addEventListener('change', () => this.updateDisplay());\n                this.frameCountInput.addEventListener('change', () => this.updateDisplay());\n                this.durationInput.addEventListener('input', () => this.updateFromDuration());\n                this.recordBtn.addEventListener('click', () => this.toggleRecording());\n                this.downloadBtn.addEventListener('click', () => this.downloadGIF());\n                this.loadCodeBtn.addEventListener('click', () => this.loadCode());\n            }\n\n            loadCode() {\n                try {\n                    this.codeManager.parseCode(this.codeInput.value);\n                    this.errorMessage.classList.remove('show');\n                    this.setStatus('Code loaded. Click Record to start.');\n                    window.codeManager = this.codeManager;\n                    window.needsReload = true;\n                } catch (error) {\n                    this.errorMessage.textContent = error.message;\n                    this.errorMessage.classList.add('show');\n                }\n            }\n\n            updateDisplay() {\n                const fps = parseInt(this.framerateInput.value);\n                const frames = parseInt(this.frameCountInput.value);\n                const duration = (frames / fps).toFixed(1);\n\n                document.getElementById('framerateDisplay').textContent = `${fps} fps`;\n                document.getElementById('frameCountDisplay').textContent = `${frames} frames (~${duration}s)`;\n                document.getElementById('durationDisplay').textContent = `${duration} seconds`;\n            }\n\n            updateFromDuration() {\n                const duration = parseFloat(this.durationInput.value);\n                const fps = parseInt(this.framerateInput.value);\n                const frames = Math.round(duration * fps);\n\n                this.frameCountInput.value = frames;\n                document.getElementById('durationDisplay').textContent = `${duration} seconds`;\n                document.getElementById('frameCountDisplay').textContent = `${frames} frames (~${duration}s)`;\n            }\n\n            toggleRecording() {\n                if (this.isRecording) {\n                    this.stopRecording();\n                } else {\n                    this.startRecording();\n                }\n            }\n\n            startRecording() {\n                const fps = parseInt(this.framerateInput.value);\n                const frameCount = parseInt(this.frameCountInput.value);\n\n                this.frameCapture = new FrameCapture(800, 800, fps, frameCount);\n                this.isRecording = true;\n                this.recordBtn.textContent = 'Stop Recording';\n                this.recordBtn.style.background = '#ff6b6b';\n                this.downloadBtn.disabled = true;\n                this.loadCodeBtn.disabled = true;\n                this.status.classList.add('recording');\n                this.setStatus(`Recording: 0/${frameCount}`);\n            }\n\n            stopRecording() {\n                this.isRecording = false;\n                this.recordBtn.textContent = 'Record';\n                this.recordBtn.style.background = '';\n                this.downloadBtn.disabled = false;\n                this.loadCodeBtn.disabled = false;\n                this.status.classList.remove('recording');\n                this.setStatus('Recording complete. Ready to download.');\n            }\n\n            setStatus(message) {\n                this.status.textContent = message;\n            }\n\n            updateStatus() {\n                if (this.frameCapture && this.isRecording) {\n                    this.setStatus(`Recording: ${this.frameCapture.getFrameCount()}/${this.frameCapture.frameCount}`);\n                }\n            }\n\n            async downloadGIF() {\n                this.recordBtn.disabled = true;\n                this.downloadBtn.disabled = true;\n                this.setStatus('Generating GIF...');\n\n                const blob = await this.frameCapture.generateGIF();\n                const url = URL.createObjectURL(blob);\n                const link = document.createElement('a');\n                link.href = url;\n                link.download = `animation-${Date.now()}.gif`;\n                link.click();\n                URL.revokeObjectURL(url);\n\n                this.recordBtn.disabled = false;\n                this.downloadBtn.disabled = false;\n                this.setStatus('GIF downloaded.');\n            }\n        }\n\n        let ui;\n        let canvas;\n        let needsReload = false;\n        let codeManager = new CodeManager();\n\n        function sketch(p) {\n            p.setup = function() {\n                canvas = p.createCanvas(800, 800);\n                canvas.parent('canvas-container');\n                \n                if (codeManager.getSetupFunction()) {\n                    try {\n                        codeManager.getSetupFunction()(p);\n                    } catch (error) {\n                        console.error('Setup error:', error);\n                    }\n                }\n            };\n\n            p.draw = function() {\n                if (window.needsReload) {\n                    window.location.reload();\n                }\n\n                if (codeManager.getDrawFunction()) {\n                    try {\n                        codeManager.getDrawFunction()(p, ui);\n                    } catch (error) {\n                        console.error('Draw error:', error);\n                    }\n                }\n\n                // Capture frame if recording\n                if (ui && ui.isRecording && ui.frameCapture) {\n                    const htmlCanvas = p.canvas;\n                    ui.frameCapture.addFrame(htmlCanvas);\n                    ui.updateStatus();\n\n                    if (ui.frameCapture.isComplete()) {\n                        ui.stopRecording();\n                    }\n                }\n            };\n        }\n\n        new p5(sketch);\n        ui = new UIController();\n        ui.updateDisplay();\n    ";
export const TOOL_FUNCTIONS = Object.fromEntries(TOOL_FUNCTION_NAMES.map((n) => [n, null]));
